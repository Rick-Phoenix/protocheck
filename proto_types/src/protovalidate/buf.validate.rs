// This file is @generated by prost-build.
/// `Rule` represents a validation rule written in the Common Expression
/// Language (CEL) syntax. Each Rule includes a unique identifier, an
/// optional error message, and the CEL expression to evaluate. For more
/// information, [see our documentation](<https://buf.build/docs/protovalidate/schemas/custom-rules/>).
///
/// ```proto
/// message Foo {
///    option (buf.validate.message).cel = {
///      id: "foo.bar"
///      message: "bar must be greater than 0"
///      expression: "this.bar > 0"
///    };
///    int32 bar = 1;
/// }
/// ```
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rule {
    /// `id` is a string that serves as a machine-readable name for this Rule.
    /// It should be unique within its scope, which could be either a message or a field.
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// `message` is an optional field that provides a human-readable error message
    /// for this Rule when the CEL expression evaluates to false. If a
    /// non-empty message is provided, any strings resulting from the CEL
    /// expression evaluation are ignored.
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// `expression` is the actual CEL expression that will be evaluated for
    /// validation. This string must resolve to either a boolean or a string
    /// value. If the expression evaluates to false or a non-empty string, the
    /// validation is considered failed, and the message is rejected.
    #[prost(string, optional, tag = "3")]
    pub expression: ::core::option::Option<::prost::alloc::string::String>,
}
/// MessageRules represents validation rules that are applied to the entire message.
/// It includes disabling options and a list of Rule messages representing Common Expression Language (CEL) validation rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageRules {
    /// `cel` is a repeated field of type Rule. Each Rule specifies a validation rule to be applied to this message.
    /// These rules are written in Common Expression Language (CEL) syntax. For more information,
    /// [see our documentation](<https://buf.build/docs/protovalidate/schemas/custom-rules/>).
    ///
    ///
    /// ```proto
    /// message MyMessage {
    ///    // The field `foo` must be greater than 42.
    ///    option (buf.validate.message).cel = {
    ///      id: "my_message.value",
    ///      message: "value must be greater than 42",
    ///      expression: "this.foo > 42",
    ///    };
    ///    optional int32 foo = 1;
    /// }
    /// ```
    #[prost(message, repeated, tag = "3")]
    pub cel: ::prost::alloc::vec::Vec<Rule>,
    /// `oneof` is a repeated field of type MessageOneofRule that specifies a list of fields
    /// of which at most one can be present. If `required` is also specified, then exactly one
    /// of the specified fields _must_ be present.
    ///
    /// This will enforce oneof-like constraints with a few features not provided by
    /// actual Protobuf oneof declarations:
    ///    1. Repeated and map fields are allowed in this validation. In a Protobuf oneof,
    ///       only scalar fields are allowed.
    ///    2. Fields with implicit presence are allowed. In a Protobuf oneof, all member
    ///       fields have explicit presence. This means that, for the purpose of determining
    ///       how many fields are set, explicitly setting such a field to its zero value is
    ///       effectively the same as not setting it at all.
    ///    3. This will always generate validation errors for a message unmarshalled from
    ///       serialized data that sets more than one field. With a Protobuf oneof, when
    ///       multiple fields are present in the serialized form, earlier values are usually
    ///       silently ignored when unmarshalling, with only the last field being set when
    ///       unmarshalling completes.
    ///
    /// Note that adding a field to a `oneof` will also set the IGNORE_IF_ZERO_VALUE on the fields. This means
    /// only the field that is set will be validated and the unset fields are not validated according to the field rules.
    /// This behavior can be overridden by setting `ignore` against a field.
    ///
    /// ```proto
    /// message MyMessage {
    ///    // Only one of `field1` or `field2` _can_ be present in this message.
    ///    option (buf.validate.message).oneof = { fields: \["field1", "field2"\] };
    ///    // Exactly one of `field3` or `field4` _must_ be present in this message.
    ///    option (buf.validate.message).oneof = { fields: \["field3", "field4"\], required: true };
    ///    string field1 = 1;
    ///    bytes field2 = 2;
    ///    bool field3 = 3;
    ///    int32 field4 = 4;
    /// }
    /// ```
    #[prost(message, repeated, tag = "4")]
    pub oneof: ::prost::alloc::vec::Vec<MessageOneofRule>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageOneofRule {
    /// A list of field names to include in the oneof. All field names must be
    /// defined in the message. At least one field must be specified, and
    /// duplicates are not permitted.
    #[prost(string, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, one of the fields specified _must_ be set.
    #[prost(bool, optional, tag = "2")]
    pub required: ::core::option::Option<bool>,
}
/// The `OneofRules` message type enables you to manage rules for
/// oneof fields in your protobuf messages.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OneofRules {
    /// If `required` is true, exactly one field of the oneof must be set. A
    /// validation error is returned if no fields in the oneof are set. Further rules
    /// should be placed on the fields themselves to ensure they are valid values,
    /// such as `min_len` or `gt`.
    ///
    /// ```proto
    /// message MyMessage {
    ///    oneof value {
    ///      // Either `a` or `b` must be set. If `a` is set, it must also be
    ///      // non-empty; whereas if `b` is set, it can still be an empty string.
    ///      option (buf.validate.oneof).required = true;
    ///      string a = 1 \[(buf.validate.field).string.min_len = 1\];
    ///      string b = 2;
    ///    }
    /// }
    /// ```
    #[prost(bool, optional, tag = "1")]
    pub required: ::core::option::Option<bool>,
}
/// FieldRules encapsulates the rules for each type of field. Depending on
/// the field, the correct set should be used to ensure proper validations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldRules {
    /// `cel` is a repeated field used to represent a textual expression
    /// in the Common Expression Language (CEL) syntax. For more information,
    /// [see our documentation](<https://buf.build/docs/protovalidate/schemas/custom-rules/>).
    ///
    /// ```proto
    /// message MyMessage {
    ///    // The field `value` must be greater than 42.
    ///    optional int32 value = 1 [(buf.validate.field).cel = {
    ///      id: "my_message.value",
    ///      message: "value must be greater than 42",
    ///      expression: "this > 42",
    ///    }];
    /// }
    /// ```
    #[prost(message, repeated, tag = "23")]
    pub cel: ::prost::alloc::vec::Vec<Rule>,
    /// If `required` is true, the field must be set. A validation error is returned
    /// if the field is not set.
    ///
    /// ```proto
    /// syntax="proto3";
    ///
    /// message FieldsWithPresence {
    ///    // Requires any string to be set, including the empty string.
    ///    optional string link = 1 [
    ///      (buf.validate.field).required = true
    ///    ];
    ///    // Requires true or false to be set.
    ///    optional bool disabled = 2 [
    ///      (buf.validate.field).required = true
    ///    ];
    ///    // Requires a message to be set, including the empty message.
    ///    SomeMessage msg = 4 [
    ///      (buf.validate.field).required = true
    ///    ];
    /// }
    /// ```
    ///
    /// All fields in the example above track presence. By default, Protovalidate
    /// ignores rules on those fields if no value is set. `required` ensures that
    /// the fields are set and valid.
    ///
    /// Fields that don't track presence are always validated by Protovalidate,
    /// whether they are set or not. It is not necessary to add `required`:
    ///
    /// ```proto
    /// syntax="proto3";
    ///
    /// message FieldsWithoutPresence {
    ///    // `string.email` always applies, even to an empty string.
    ///    string link = 1 [
    ///      (buf.validate.field).string.email = true
    ///    ];
    ///    // `repeated.min_items` always applies, even to an empty list.
    ///    repeated string labels = 4 [
    ///      (buf.validate.field).repeated.min_items = 1
    ///    ];
    /// }
    /// ```
    ///
    /// To learn which fields track presence, see the
    /// [Field Presence cheat sheet](<https://protobuf.dev/programming-guides/field_presence/#cheat>).
    ///
    /// Note: While field rules can be applied to repeated items, map keys, and map
    /// values, the elements are always considered to be set. Consequently,
    /// specifying `repeated.items.required` is redundant.
    #[prost(bool, optional, tag = "25")]
    pub required: ::core::option::Option<bool>,
    /// Ignore validation rules on the field if its value matches the specified
    /// criteria. See the `Ignore` enum for details.
    ///
    /// ```proto
    /// message UpdateRequest {
    ///    // The uri rule only applies if the field is not an empty string.
    ///    string url = 1 [
    ///      (buf.validate.field).ignore = IGNORE_IF_ZERO_VALUE,
    ///      (buf.validate.field).string.uri = true
    ///    ];
    /// }
    /// ```
    #[prost(enumeration = "Ignore", optional, tag = "27")]
    pub ignore: ::core::option::Option<i32>,
    #[prost(
        oneof = "field_rules::Type",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22"
    )]
    pub r#type: ::core::option::Option<field_rules::Type>,
}
/// Nested message and enum types in `FieldRules`.
pub mod field_rules {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Scalar Field Types
        #[prost(message, tag = "1")]
        Float(super::FloatRules),
        #[prost(message, tag = "2")]
        Double(super::DoubleRules),
        #[prost(message, tag = "3")]
        Int32(super::Int32Rules),
        #[prost(message, tag = "4")]
        Int64(super::Int64Rules),
        #[prost(message, tag = "5")]
        Uint32(super::UInt32Rules),
        #[prost(message, tag = "6")]
        Uint64(super::UInt64Rules),
        #[prost(message, tag = "7")]
        Sint32(super::SInt32Rules),
        #[prost(message, tag = "8")]
        Sint64(super::SInt64Rules),
        #[prost(message, tag = "9")]
        Fixed32(super::Fixed32Rules),
        #[prost(message, tag = "10")]
        Fixed64(super::Fixed64Rules),
        #[prost(message, tag = "11")]
        Sfixed32(super::SFixed32Rules),
        #[prost(message, tag = "12")]
        Sfixed64(super::SFixed64Rules),
        #[prost(message, tag = "13")]
        Bool(super::BoolRules),
        #[prost(message, tag = "14")]
        String(super::StringRules),
        #[prost(message, tag = "15")]
        Bytes(super::BytesRules),
        /// Complex Field Types
        #[prost(message, tag = "16")]
        Enum(super::EnumRules),
        #[prost(message, tag = "18")]
        Repeated(::prost::alloc::boxed::Box<super::RepeatedRules>),
        #[prost(message, tag = "19")]
        Map(::prost::alloc::boxed::Box<super::MapRules>),
        /// Well-Known Field Types
        #[prost(message, tag = "20")]
        Any(super::AnyRules),
        #[prost(message, tag = "21")]
        Duration(super::DurationRules),
        #[prost(message, tag = "22")]
        Timestamp(super::TimestampRules),
    }
}
/// PredefinedRules are custom rules that can be re-used with
/// multiple fields.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredefinedRules {
    /// `cel` is a repeated field used to represent a textual expression
    /// in the Common Expression Language (CEL) syntax. For more information,
    /// [see our documentation](<https://buf.build/docs/protovalidate/schemas/predefined-rules/>).
    ///
    /// ```proto
    /// message MyMessage {
    ///    // The field `value` must be greater than 42.
    ///    optional int32 value = 1 [(buf.validate.predefined).cel = {
    ///      id: "my_message.value",
    ///      message: "value must be greater than 42",
    ///      expression: "this > 42",
    ///    }];
    /// }
    /// ```
    #[prost(message, repeated, tag = "1")]
    pub cel: ::prost::alloc::vec::Vec<Rule>,
}
/// FloatRules describes the rules applied to `float` values. These
/// rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloatRules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyFloat {
    ///    // value must equal 42.0
    ///    float value = 1 \[(buf.validate.field).float.const = 42.0\];
    /// }
    /// ```
    #[prost(float, optional, tag = "1")]
    pub r#const: ::core::option::Option<f32>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message
    /// is generated.
    ///
    /// ```proto
    /// message MyFloat {
    ///    // value must be in list \[1.0, 2.0, 3.0\]
    ///    float value = 1 \[(buf.validate.field).float = { in: [1.0, 2.0, 3.0\] }];
    /// }
    /// ```
    #[prost(float, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<f32>,
    /// `in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyFloat {
    ///    // value must not be in list \[1.0, 2.0, 3.0\]
    ///    float value = 1 \[(buf.validate.field).float = { not_in: [1.0, 2.0, 3.0\] }];
    /// }
    /// ```
    #[prost(float, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<f32>,
    /// `finite` requires the field value to be finite. If the field value is
    /// infinite or NaN, an error message is generated.
    #[prost(bool, optional, tag = "8")]
    pub finite: ::core::option::Option<bool>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyFloat {
    ///    float value = 1 [
    ///      (buf.validate.field).float.example = 1.0,
    ///      (buf.validate.field).float.example = inf
    ///    ];
    /// }
    /// ```
    #[prost(float, repeated, packed = "false", tag = "9")]
    pub example: ::prost::alloc::vec::Vec<f32>,
    #[prost(oneof = "float_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<float_rules::LessThan>,
    #[prost(oneof = "float_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<float_rules::GreaterThan>,
}
/// Nested message and enum types in `FloatRules`.
pub mod float_rules {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFloat {
        ///    // value must be less than 10.0
        ///    float value = 1 \[(buf.validate.field).float.lt = 10.0\];
        /// }
        /// ```
        #[prost(float, tag = "2")]
        Lt(f32),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyFloat {
        ///    // value must be less than or equal to 10.0
        ///    float value = 1 \[(buf.validate.field).float.lte = 10.0\];
        /// }
        /// ```
        #[prost(float, tag = "3")]
        Lte(f32),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFloat {
        ///    // value must be greater than 5.0 \[float.gt\]
        ///    float value = 1 \[(buf.validate.field).float.gt = 5.0\];
        ///
        ///    // value must be greater than 5 and less than 10.0 \[float.gt_lt\]
        ///    float other_value = 2 \[(buf.validate.field).float = { gt: 5.0, lt: 10.0 }\];
        ///
        ///    // value must be greater than 10 or less than 5.0 \[float.gt_lt_exclusive\]
        ///    float another_value = 3 \[(buf.validate.field).float = { gt: 10.0, lt: 5.0 }\];
        /// }
        /// ```
        #[prost(float, tag = "4")]
        Gt(f32),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFloat {
        ///    // value must be greater than or equal to 5.0 \[float.gte\]
        ///    float value = 1 \[(buf.validate.field).float.gte = 5.0\];
        ///
        ///    // value must be greater than or equal to 5.0 and less than 10.0 \[float.gte_lt\]
        ///    float other_value = 2 \[(buf.validate.field).float = { gte: 5.0, lt: 10.0 }\];
        ///
        ///    // value must be greater than or equal to 10.0 or less than 5.0 \[float.gte_lt_exclusive\]
        ///    float another_value = 3 \[(buf.validate.field).float = { gte: 10.0, lt: 5.0 }\];
        /// }
        /// ```
        #[prost(float, tag = "5")]
        Gte(f32),
    }
}
/// DoubleRules describes the rules applied to `double` values. These
/// rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleRules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyDouble {
    ///    // value must equal 42.0
    ///    double value = 1 \[(buf.validate.field).double.const = 42.0\];
    /// }
    /// ```
    #[prost(double, optional, tag = "1")]
    pub r#const: ::core::option::Option<f64>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MyDouble {
    ///    // value must be in list \[1.0, 2.0, 3.0\]
    ///    double value = 1 \[(buf.validate.field).double = { in: [1.0, 2.0, 3.0\] }];
    /// }
    /// ```
    #[prost(double, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<f64>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyDouble {
    ///    // value must not be in list \[1.0, 2.0, 3.0\]
    ///    double value = 1 \[(buf.validate.field).double = { not_in: [1.0, 2.0, 3.0\] }];
    /// }
    /// ```
    #[prost(double, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<f64>,
    /// `finite` requires the field value to be finite. If the field value is
    /// infinite or NaN, an error message is generated.
    #[prost(bool, optional, tag = "8")]
    pub finite: ::core::option::Option<bool>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyDouble {
    ///    double value = 1 [
    ///      (buf.validate.field).double.example = 1.0,
    ///      (buf.validate.field).double.example = inf
    ///    ];
    /// }
    /// ```
    #[prost(double, repeated, packed = "false", tag = "9")]
    pub example: ::prost::alloc::vec::Vec<f64>,
    #[prost(oneof = "double_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<double_rules::LessThan>,
    #[prost(oneof = "double_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<double_rules::GreaterThan>,
}
/// Nested message and enum types in `DoubleRules`.
pub mod double_rules {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyDouble {
        ///    // value must be less than 10.0
        ///    double value = 1 \[(buf.validate.field).double.lt = 10.0\];
        /// }
        /// ```
        #[prost(double, tag = "2")]
        Lt(f64),
        /// `lte` requires the field value to be less than or equal to the specified value
        /// (field <= value). If the field value is greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyDouble {
        ///    // value must be less than or equal to 10.0
        ///    double value = 1 \[(buf.validate.field).double.lte = 10.0\];
        /// }
        /// ```
        #[prost(double, tag = "3")]
        Lte(f64),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
        /// the range is reversed, and the field value must be outside the specified
        /// range. If the field value doesn't meet the required conditions, an error
        /// message is generated.
        ///
        /// ```proto
        /// message MyDouble {
        ///    // value must be greater than 5.0 \[double.gt\]
        ///    double value = 1 \[(buf.validate.field).double.gt = 5.0\];
        ///
        ///    // value must be greater than 5 and less than 10.0 \[double.gt_lt\]
        ///    double other_value = 2 \[(buf.validate.field).double = { gt: 5.0, lt: 10.0 }\];
        ///
        ///    // value must be greater than 10 or less than 5.0 \[double.gt_lt_exclusive\]
        ///    double another_value = 3 \[(buf.validate.field).double = { gt: 10.0, lt: 5.0 }\];
        /// }
        /// ```
        #[prost(double, tag = "4")]
        Gt(f64),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyDouble {
        ///    // value must be greater than or equal to 5.0 \[double.gte\]
        ///    double value = 1 \[(buf.validate.field).double.gte = 5.0\];
        ///
        ///    // value must be greater than or equal to 5.0 and less than 10.0 \[double.gte_lt\]
        ///    double other_value = 2 \[(buf.validate.field).double = { gte: 5.0, lt: 10.0 }\];
        ///
        ///    // value must be greater than or equal to 10.0 or less than 5.0 \[double.gte_lt_exclusive\]
        ///    double another_value = 3 \[(buf.validate.field).double = { gte: 10.0, lt: 5.0 }\];
        /// }
        /// ```
        #[prost(double, tag = "5")]
        Gte(f64),
    }
}
/// Int32Rules describes the rules applied to `int32` values. These
/// rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Int32Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyInt32 {
    ///    // value must equal 42
    ///    int32 value = 1 \[(buf.validate.field).int32.const = 42\];
    /// }
    /// ```
    #[prost(int32, optional, tag = "1")]
    pub r#const: ::core::option::Option<i32>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MyInt32 {
    ///    // value must be in list \[1, 2, 3\]
    ///    int32 value = 1 \[(buf.validate.field).int32 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error message
    /// is generated.
    ///
    /// ```proto
    /// message MyInt32 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    int32 value = 1 \[(buf.validate.field).int32 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(int32, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyInt32 {
    ///    int32 value = 1 [
    ///      (buf.validate.field).int32.example = 1,
    ///      (buf.validate.field).int32.example = -10
    ///    ];
    /// }
    /// ```
    #[prost(int32, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof = "int32_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<int32_rules::LessThan>,
    #[prost(oneof = "int32_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<int32_rules::GreaterThan>,
}
/// Nested message and enum types in `Int32Rules`.
pub mod int32_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field
        /// < value). If the field value is equal to or greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyInt32 {
        ///    // value must be less than 10
        ///    int32 value = 1 \[(buf.validate.field).int32.lt = 10\];
        /// }
        /// ```
        #[prost(int32, tag = "2")]
        Lt(i32),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyInt32 {
        ///    // value must be less than or equal to 10
        ///    int32 value = 1 \[(buf.validate.field).int32.lte = 10\];
        /// }
        /// ```
        #[prost(int32, tag = "3")]
        Lte(i32),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyInt32 {
        ///    // value must be greater than 5 \[int32.gt\]
        ///    int32 value = 1 \[(buf.validate.field).int32.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[int32.gt_lt\]
        ///    int32 other_value = 2 \[(buf.validate.field).int32 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[int32.gt_lt_exclusive\]
        ///    int32 another_value = 3 \[(buf.validate.field).int32 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(int32, tag = "4")]
        Gt(i32),
        /// `gte` requires the field value to be greater than or equal to the specified value
        /// (exclusive). If the value of `gte` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyInt32 {
        ///    // value must be greater than or equal to 5 \[int32.gte\]
        ///    int32 value = 1 \[(buf.validate.field).int32.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[int32.gte_lt\]
        ///    int32 other_value = 2 \[(buf.validate.field).int32 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[int32.gte_lt_exclusive\]
        ///    int32 another_value = 3 \[(buf.validate.field).int32 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(int32, tag = "5")]
        Gte(i32),
    }
}
/// Int64Rules describes the rules applied to `int64` values. These
/// rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Int64Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyInt64 {
    ///    // value must equal 42
    ///    int64 value = 1 \[(buf.validate.field).int64.const = 42\];
    /// }
    /// ```
    #[prost(int64, optional, tag = "1")]
    pub r#const: ::core::option::Option<i64>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MyInt64 {
    ///    // value must be in list \[1, 2, 3\]
    ///    int64 value = 1 \[(buf.validate.field).int64 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(int64, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<i64>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyInt64 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    int64 value = 1 \[(buf.validate.field).int64 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(int64, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<i64>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyInt64 {
    ///    int64 value = 1 [
    ///      (buf.validate.field).int64.example = 1,
    ///      (buf.validate.field).int64.example = -10
    ///    ];
    /// }
    /// ```
    #[prost(int64, repeated, packed = "false", tag = "9")]
    pub example: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof = "int64_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<int64_rules::LessThan>,
    #[prost(oneof = "int64_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<int64_rules::GreaterThan>,
}
/// Nested message and enum types in `Int64Rules`.
pub mod int64_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyInt64 {
        ///    // value must be less than 10
        ///    int64 value = 1 \[(buf.validate.field).int64.lt = 10\];
        /// }
        /// ```
        #[prost(int64, tag = "2")]
        Lt(i64),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyInt64 {
        ///    // value must be less than or equal to 10
        ///    int64 value = 1 \[(buf.validate.field).int64.lte = 10\];
        /// }
        /// ```
        #[prost(int64, tag = "3")]
        Lte(i64),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyInt64 {
        ///    // value must be greater than 5 \[int64.gt\]
        ///    int64 value = 1 \[(buf.validate.field).int64.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[int64.gt_lt\]
        ///    int64 other_value = 2 \[(buf.validate.field).int64 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[int64.gt_lt_exclusive\]
        ///    int64 another_value = 3 \[(buf.validate.field).int64 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(int64, tag = "4")]
        Gt(i64),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyInt64 {
        ///    // value must be greater than or equal to 5 \[int64.gte\]
        ///    int64 value = 1 \[(buf.validate.field).int64.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[int64.gte_lt\]
        ///    int64 other_value = 2 \[(buf.validate.field).int64 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[int64.gte_lt_exclusive\]
        ///    int64 another_value = 3 \[(buf.validate.field).int64 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(int64, tag = "5")]
        Gte(i64),
    }
}
/// UInt32Rules describes the rules applied to `uint32` values. These
/// rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UInt32Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyUInt32 {
    ///    // value must equal 42
    ///    uint32 value = 1 \[(buf.validate.field).uint32.const = 42\];
    /// }
    /// ```
    #[prost(uint32, optional, tag = "1")]
    pub r#const: ::core::option::Option<u32>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MyUInt32 {
    ///    // value must be in list \[1, 2, 3\]
    ///    uint32 value = 1 \[(buf.validate.field).uint32 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(uint32, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<u32>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyUInt32 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    uint32 value = 1 \[(buf.validate.field).uint32 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(uint32, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<u32>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyUInt32 {
    ///    uint32 value = 1 [
    ///      (buf.validate.field).uint32.example = 1,
    ///      (buf.validate.field).uint32.example = 10
    ///    ];
    /// }
    /// ```
    #[prost(uint32, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<u32>,
    #[prost(oneof = "u_int32_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<u_int32_rules::LessThan>,
    #[prost(oneof = "u_int32_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<u_int32_rules::GreaterThan>,
}
/// Nested message and enum types in `UInt32Rules`.
pub mod u_int32_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyUInt32 {
        ///    // value must be less than 10
        ///    uint32 value = 1 \[(buf.validate.field).uint32.lt = 10\];
        /// }
        /// ```
        #[prost(uint32, tag = "2")]
        Lt(u32),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyUInt32 {
        ///    // value must be less than or equal to 10
        ///    uint32 value = 1 \[(buf.validate.field).uint32.lte = 10\];
        /// }
        /// ```
        #[prost(uint32, tag = "3")]
        Lte(u32),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyUInt32 {
        ///    // value must be greater than 5 \[uint32.gt\]
        ///    uint32 value = 1 \[(buf.validate.field).uint32.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[uint32.gt_lt\]
        ///    uint32 other_value = 2 \[(buf.validate.field).uint32 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[uint32.gt_lt_exclusive\]
        ///    uint32 another_value = 3 \[(buf.validate.field).uint32 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(uint32, tag = "4")]
        Gt(u32),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyUInt32 {
        ///    // value must be greater than or equal to 5 \[uint32.gte\]
        ///    uint32 value = 1 \[(buf.validate.field).uint32.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[uint32.gte_lt\]
        ///    uint32 other_value = 2 \[(buf.validate.field).uint32 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[uint32.gte_lt_exclusive\]
        ///    uint32 another_value = 3 \[(buf.validate.field).uint32 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(uint32, tag = "5")]
        Gte(u32),
    }
}
/// UInt64Rules describes the rules applied to `uint64` values. These
/// rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UInt64Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyUInt64 {
    ///    // value must equal 42
    ///    uint64 value = 1 \[(buf.validate.field).uint64.const = 42\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "1")]
    pub r#const: ::core::option::Option<u64>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MyUInt64 {
    ///    // value must be in list \[1, 2, 3\]
    ///    uint64 value = 1 \[(buf.validate.field).uint64 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(uint64, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<u64>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyUInt64 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    uint64 value = 1 \[(buf.validate.field).uint64 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(uint64, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<u64>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyUInt64 {
    ///    uint64 value = 1 [
    ///      (buf.validate.field).uint64.example = 1,
    ///      (buf.validate.field).uint64.example = -10
    ///    ];
    /// }
    /// ```
    #[prost(uint64, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<u64>,
    #[prost(oneof = "u_int64_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<u_int64_rules::LessThan>,
    #[prost(oneof = "u_int64_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<u_int64_rules::GreaterThan>,
}
/// Nested message and enum types in `UInt64Rules`.
pub mod u_int64_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyUInt64 {
        ///    // value must be less than 10
        ///    uint64 value = 1 \[(buf.validate.field).uint64.lt = 10\];
        /// }
        /// ```
        #[prost(uint64, tag = "2")]
        Lt(u64),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyUInt64 {
        ///    // value must be less than or equal to 10
        ///    uint64 value = 1 \[(buf.validate.field).uint64.lte = 10\];
        /// }
        /// ```
        #[prost(uint64, tag = "3")]
        Lte(u64),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyUInt64 {
        ///    // value must be greater than 5 \[uint64.gt\]
        ///    uint64 value = 1 \[(buf.validate.field).uint64.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[uint64.gt_lt\]
        ///    uint64 other_value = 2 \[(buf.validate.field).uint64 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[uint64.gt_lt_exclusive\]
        ///    uint64 another_value = 3 \[(buf.validate.field).uint64 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(uint64, tag = "4")]
        Gt(u64),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyUInt64 {
        ///    // value must be greater than or equal to 5 \[uint64.gte\]
        ///    uint64 value = 1 \[(buf.validate.field).uint64.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[uint64.gte_lt\]
        ///    uint64 other_value = 2 \[(buf.validate.field).uint64 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[uint64.gte_lt_exclusive\]
        ///    uint64 another_value = 3 \[(buf.validate.field).uint64 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(uint64, tag = "5")]
        Gte(u64),
    }
}
/// SInt32Rules describes the rules applied to `sint32` values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SInt32Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MySInt32 {
    ///    // value must equal 42
    ///    sint32 value = 1 \[(buf.validate.field).sint32.const = 42\];
    /// }
    /// ```
    #[prost(sint32, optional, tag = "1")]
    pub r#const: ::core::option::Option<i32>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MySInt32 {
    ///    // value must be in list \[1, 2, 3\]
    ///    sint32 value = 1 \[(buf.validate.field).sint32 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sint32, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MySInt32 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    sint32 value = 1 \[(buf.validate.field).sint32 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sint32, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MySInt32 {
    ///    sint32 value = 1 [
    ///      (buf.validate.field).sint32.example = 1,
    ///      (buf.validate.field).sint32.example = -10
    ///    ];
    /// }
    /// ```
    #[prost(sint32, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof = "s_int32_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<s_int32_rules::LessThan>,
    #[prost(oneof = "s_int32_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<s_int32_rules::GreaterThan>,
}
/// Nested message and enum types in `SInt32Rules`.
pub mod s_int32_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field
        /// < value). If the field value is equal to or greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MySInt32 {
        ///    // value must be less than 10
        ///    sint32 value = 1 \[(buf.validate.field).sint32.lt = 10\];
        /// }
        /// ```
        #[prost(sint32, tag = "2")]
        Lt(i32),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MySInt32 {
        ///    // value must be less than or equal to 10
        ///    sint32 value = 1 \[(buf.validate.field).sint32.lte = 10\];
        /// }
        /// ```
        #[prost(sint32, tag = "3")]
        Lte(i32),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySInt32 {
        ///    // value must be greater than 5 \[sint32.gt\]
        ///    sint32 value = 1 \[(buf.validate.field).sint32.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[sint32.gt_lt\]
        ///    sint32 other_value = 2 \[(buf.validate.field).sint32 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[sint32.gt_lt_exclusive\]
        ///    sint32 another_value = 3 \[(buf.validate.field).sint32 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sint32, tag = "4")]
        Gt(i32),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySInt32 {
        ///   // value must be greater than or equal to 5 \[sint32.gte\]
        ///   sint32 value = 1 \[(buf.validate.field).sint32.gte = 5\];
        ///
        ///   // value must be greater than or equal to 5 and less than 10 \[sint32.gte_lt\]
        ///   sint32 other_value = 2 \[(buf.validate.field).sint32 = { gte: 5, lt: 10 }\];
        ///
        ///   // value must be greater than or equal to 10 or less than 5 \[sint32.gte_lt_exclusive\]
        ///   sint32 another_value = 3 \[(buf.validate.field).sint32 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sint32, tag = "5")]
        Gte(i32),
    }
}
/// SInt64Rules describes the rules applied to `sint64` values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SInt64Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MySInt64 {
    ///    // value must equal 42
    ///    sint64 value = 1 \[(buf.validate.field).sint64.const = 42\];
    /// }
    /// ```
    #[prost(sint64, optional, tag = "1")]
    pub r#const: ::core::option::Option<i64>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message
    /// is generated.
    ///
    /// ```proto
    /// message MySInt64 {
    ///    // value must be in list \[1, 2, 3\]
    ///    sint64 value = 1 \[(buf.validate.field).sint64 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sint64, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<i64>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MySInt64 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    sint64 value = 1 \[(buf.validate.field).sint64 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sint64, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<i64>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MySInt64 {
    ///    sint64 value = 1 [
    ///      (buf.validate.field).sint64.example = 1,
    ///      (buf.validate.field).sint64.example = -10
    ///    ];
    /// }
    /// ```
    #[prost(sint64, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof = "s_int64_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<s_int64_rules::LessThan>,
    #[prost(oneof = "s_int64_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<s_int64_rules::GreaterThan>,
}
/// Nested message and enum types in `SInt64Rules`.
pub mod s_int64_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field
        /// < value). If the field value is equal to or greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MySInt64 {
        ///    // value must be less than 10
        ///    sint64 value = 1 \[(buf.validate.field).sint64.lt = 10\];
        /// }
        /// ```
        #[prost(sint64, tag = "2")]
        Lt(i64),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MySInt64 {
        ///    // value must be less than or equal to 10
        ///    sint64 value = 1 \[(buf.validate.field).sint64.lte = 10\];
        /// }
        /// ```
        #[prost(sint64, tag = "3")]
        Lte(i64),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySInt64 {
        ///    // value must be greater than 5 \[sint64.gt\]
        ///    sint64 value = 1 \[(buf.validate.field).sint64.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[sint64.gt_lt\]
        ///    sint64 other_value = 2 \[(buf.validate.field).sint64 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[sint64.gt_lt_exclusive\]
        ///    sint64 another_value = 3 \[(buf.validate.field).sint64 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sint64, tag = "4")]
        Gt(i64),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySInt64 {
        ///    // value must be greater than or equal to 5 \[sint64.gte\]
        ///    sint64 value = 1 \[(buf.validate.field).sint64.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[sint64.gte_lt\]
        ///    sint64 other_value = 2 \[(buf.validate.field).sint64 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[sint64.gte_lt_exclusive\]
        ///    sint64 another_value = 3 \[(buf.validate.field).sint64 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sint64, tag = "5")]
        Gte(i64),
    }
}
/// Fixed32Rules describes the rules applied to `fixed32` values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Fixed32Rules {
    /// `const` requires the field value to exactly match the specified value.
    /// If the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyFixed32 {
    ///    // value must equal 42
    ///    fixed32 value = 1 \[(buf.validate.field).fixed32.const = 42\];
    /// }
    /// ```
    #[prost(fixed32, optional, tag = "1")]
    pub r#const: ::core::option::Option<u32>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message
    /// is generated.
    ///
    /// ```proto
    /// message MyFixed32 {
    ///    // value must be in list \[1, 2, 3\]
    ///    fixed32 value = 1 \[(buf.validate.field).fixed32 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(fixed32, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<u32>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyFixed32 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    fixed32 value = 1 \[(buf.validate.field).fixed32 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(fixed32, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<u32>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyFixed32 {
    ///    fixed32 value = 1 [
    ///      (buf.validate.field).fixed32.example = 1,
    ///      (buf.validate.field).fixed32.example = 2
    ///    ];
    /// }
    /// ```
    #[prost(fixed32, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<u32>,
    #[prost(oneof = "fixed32_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<fixed32_rules::LessThan>,
    #[prost(oneof = "fixed32_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<fixed32_rules::GreaterThan>,
}
/// Nested message and enum types in `Fixed32Rules`.
pub mod fixed32_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFixed32 {
        ///    // value must be less than 10
        ///    fixed32 value = 1 \[(buf.validate.field).fixed32.lt = 10\];
        /// }
        /// ```
        #[prost(fixed32, tag = "2")]
        Lt(u32),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyFixed32 {
        ///    // value must be less than or equal to 10
        ///    fixed32 value = 1 \[(buf.validate.field).fixed32.lte = 10\];
        /// }
        /// ```
        #[prost(fixed32, tag = "3")]
        Lte(u32),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFixed32 {
        ///    // value must be greater than 5 \[fixed32.gt\]
        ///    fixed32 value = 1 \[(buf.validate.field).fixed32.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[fixed32.gt_lt\]
        ///    fixed32 other_value = 2 \[(buf.validate.field).fixed32 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[fixed32.gt_lt_exclusive\]
        ///    fixed32 another_value = 3 \[(buf.validate.field).fixed32 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(fixed32, tag = "4")]
        Gt(u32),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFixed32 {
        ///    // value must be greater than or equal to 5 \[fixed32.gte\]
        ///    fixed32 value = 1 \[(buf.validate.field).fixed32.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[fixed32.gte_lt\]
        ///    fixed32 other_value = 2 \[(buf.validate.field).fixed32 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[fixed32.gte_lt_exclusive\]
        ///    fixed32 another_value = 3 \[(buf.validate.field).fixed32 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(fixed32, tag = "5")]
        Gte(u32),
    }
}
/// Fixed64Rules describes the rules applied to `fixed64` values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Fixed64Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyFixed64 {
    ///    // value must equal 42
    ///    fixed64 value = 1 \[(buf.validate.field).fixed64.const = 42\];
    /// }
    /// ```
    #[prost(fixed64, optional, tag = "1")]
    pub r#const: ::core::option::Option<u64>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MyFixed64 {
    ///    // value must be in list \[1, 2, 3\]
    ///    fixed64 value = 1 \[(buf.validate.field).fixed64 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(fixed64, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<u64>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyFixed64 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    fixed64 value = 1 \[(buf.validate.field).fixed64 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(fixed64, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<u64>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyFixed64 {
    ///    fixed64 value = 1 [
    ///      (buf.validate.field).fixed64.example = 1,
    ///      (buf.validate.field).fixed64.example = 2
    ///    ];
    /// }
    /// ```
    #[prost(fixed64, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<u64>,
    #[prost(oneof = "fixed64_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<fixed64_rules::LessThan>,
    #[prost(oneof = "fixed64_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<fixed64_rules::GreaterThan>,
}
/// Nested message and enum types in `Fixed64Rules`.
pub mod fixed64_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFixed64 {
        ///    // value must be less than 10
        ///    fixed64 value = 1 \[(buf.validate.field).fixed64.lt = 10\];
        /// }
        /// ```
        #[prost(fixed64, tag = "2")]
        Lt(u64),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MyFixed64 {
        ///    // value must be less than or equal to 10
        ///    fixed64 value = 1 \[(buf.validate.field).fixed64.lte = 10\];
        /// }
        /// ```
        #[prost(fixed64, tag = "3")]
        Lte(u64),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFixed64 {
        ///    // value must be greater than 5 \[fixed64.gt\]
        ///    fixed64 value = 1 \[(buf.validate.field).fixed64.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[fixed64.gt_lt\]
        ///    fixed64 other_value = 2 \[(buf.validate.field).fixed64 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[fixed64.gt_lt_exclusive\]
        ///    fixed64 another_value = 3 \[(buf.validate.field).fixed64 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(fixed64, tag = "4")]
        Gt(u64),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyFixed64 {
        ///    // value must be greater than or equal to 5 \[fixed64.gte\]
        ///    fixed64 value = 1 \[(buf.validate.field).fixed64.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[fixed64.gte_lt\]
        ///    fixed64 other_value = 2 \[(buf.validate.field).fixed64 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[fixed64.gte_lt_exclusive\]
        ///    fixed64 another_value = 3 \[(buf.validate.field).fixed64 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(fixed64, tag = "5")]
        Gte(u64),
    }
}
/// SFixed32Rules describes the rules applied to `fixed32` values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SFixed32Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MySFixed32 {
    ///    // value must equal 42
    ///    sfixed32 value = 1 \[(buf.validate.field).sfixed32.const = 42\];
    /// }
    /// ```
    #[prost(sfixed32, optional, tag = "1")]
    pub r#const: ::core::option::Option<i32>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MySFixed32 {
    ///    // value must be in list \[1, 2, 3\]
    ///    sfixed32 value = 1 \[(buf.validate.field).sfixed32 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sfixed32, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MySFixed32 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    sfixed32 value = 1 \[(buf.validate.field).sfixed32 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sfixed32, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MySFixed32 {
    ///    sfixed32 value = 1 [
    ///      (buf.validate.field).sfixed32.example = 1,
    ///      (buf.validate.field).sfixed32.example = 2
    ///    ];
    /// }
    /// ```
    #[prost(sfixed32, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof = "s_fixed32_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<s_fixed32_rules::LessThan>,
    #[prost(oneof = "s_fixed32_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<s_fixed32_rules::GreaterThan>,
}
/// Nested message and enum types in `SFixed32Rules`.
pub mod s_fixed32_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySFixed32 {
        ///    // value must be less than 10
        ///    sfixed32 value = 1 \[(buf.validate.field).sfixed32.lt = 10\];
        /// }
        /// ```
        #[prost(sfixed32, tag = "2")]
        Lt(i32),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MySFixed32 {
        ///    // value must be less than or equal to 10
        ///    sfixed32 value = 1 \[(buf.validate.field).sfixed32.lte = 10\];
        /// }
        /// ```
        #[prost(sfixed32, tag = "3")]
        Lte(i32),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySFixed32 {
        ///    // value must be greater than 5 \[sfixed32.gt\]
        ///    sfixed32 value = 1 \[(buf.validate.field).sfixed32.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[sfixed32.gt_lt\]
        ///    sfixed32 other_value = 2 \[(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[sfixed32.gt_lt_exclusive\]
        ///    sfixed32 another_value = 3 \[(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sfixed32, tag = "4")]
        Gt(i32),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySFixed32 {
        ///    // value must be greater than or equal to 5 \[sfixed32.gte\]
        ///    sfixed32 value = 1 \[(buf.validate.field).sfixed32.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[sfixed32.gte_lt\]
        ///    sfixed32 other_value = 2 \[(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[sfixed32.gte_lt_exclusive\]
        ///    sfixed32 another_value = 3 \[(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sfixed32, tag = "5")]
        Gte(i32),
    }
}
/// SFixed64Rules describes the rules applied to `fixed64` values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SFixed64Rules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MySFixed64 {
    ///    // value must equal 42
    ///    sfixed64 value = 1 \[(buf.validate.field).sfixed64.const = 42\];
    /// }
    /// ```
    #[prost(sfixed64, optional, tag = "1")]
    pub r#const: ::core::option::Option<i64>,
    /// `in` requires the field value to be equal to one of the specified values.
    /// If the field value isn't one of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MySFixed64 {
    ///    // value must be in list \[1, 2, 3\]
    ///    sfixed64 value = 1 \[(buf.validate.field).sfixed64 = { in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sfixed64, repeated, packed = "false", tag = "6")]
    pub r#in: ::prost::alloc::vec::Vec<i64>,
    /// `not_in` requires the field value to not be equal to any of the specified
    /// values. If the field value is one of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MySFixed64 {
    ///    // value must not be in list \[1, 2, 3\]
    ///    sfixed64 value = 1 \[(buf.validate.field).sfixed64 = { not_in: [1, 2, 3\] }];
    /// }
    /// ```
    #[prost(sfixed64, repeated, packed = "false", tag = "7")]
    pub not_in: ::prost::alloc::vec::Vec<i64>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MySFixed64 {
    ///    sfixed64 value = 1 [
    ///      (buf.validate.field).sfixed64.example = 1,
    ///      (buf.validate.field).sfixed64.example = 2
    ///    ];
    /// }
    /// ```
    #[prost(sfixed64, repeated, packed = "false", tag = "8")]
    pub example: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof = "s_fixed64_rules::LessThan", tags = "2, 3")]
    pub less_than: ::core::option::Option<s_fixed64_rules::LessThan>,
    #[prost(oneof = "s_fixed64_rules::GreaterThan", tags = "4, 5")]
    pub greater_than: ::core::option::Option<s_fixed64_rules::GreaterThan>,
}
/// Nested message and enum types in `SFixed64Rules`.
pub mod s_fixed64_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` requires the field value to be less than the specified value (field <
        /// value). If the field value is equal to or greater than the specified value,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySFixed64 {
        ///    // value must be less than 10
        ///    sfixed64 value = 1 \[(buf.validate.field).sfixed64.lt = 10\];
        /// }
        /// ```
        #[prost(sfixed64, tag = "2")]
        Lt(i64),
        /// `lte` requires the field value to be less than or equal to the specified
        /// value (field <= value). If the field value is greater than the specified
        /// value, an error message is generated.
        ///
        /// ```proto
        /// message MySFixed64 {
        ///    // value must be less than or equal to 10
        ///    sfixed64 value = 1 \[(buf.validate.field).sfixed64.lte = 10\];
        /// }
        /// ```
        #[prost(sfixed64, tag = "3")]
        Lte(i64),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the field value to be greater than the specified value
        /// (exclusive). If the value of `gt` is larger than a specified `lt` or
        /// `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySFixed64 {
        ///    // value must be greater than 5 \[sfixed64.gt\]
        ///    sfixed64 value = 1 \[(buf.validate.field).sfixed64.gt = 5\];
        ///
        ///    // value must be greater than 5 and less than 10 \[sfixed64.gt_lt\]
        ///    sfixed64 other_value = 2 \[(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }\];
        ///
        ///    // value must be greater than 10 or less than 5 \[sfixed64.gt_lt_exclusive\]
        ///    sfixed64 another_value = 3 \[(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sfixed64, tag = "4")]
        Gt(i64),
        /// `gte` requires the field value to be greater than or equal to the specified
        /// value (exclusive). If the value of `gte` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MySFixed64 {
        ///    // value must be greater than or equal to 5 \[sfixed64.gte\]
        ///    sfixed64 value = 1 \[(buf.validate.field).sfixed64.gte = 5\];
        ///
        ///    // value must be greater than or equal to 5 and less than 10 \[sfixed64.gte_lt\]
        ///    sfixed64 other_value = 2 \[(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }\];
        ///
        ///    // value must be greater than or equal to 10 or less than 5 \[sfixed64.gte_lt_exclusive\]
        ///    sfixed64 another_value = 3 \[(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }\];
        /// }
        /// ```
        #[prost(sfixed64, tag = "5")]
        Gte(i64),
    }
}
/// BoolRules describes the rules applied to `bool` values. These rules
/// may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BoolRules {
    /// `const` requires the field value to exactly match the specified boolean value.
    /// If the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyBool {
    ///    // value must equal true
    ///    bool value = 1 \[(buf.validate.field).bool.const = true\];
    /// }
    /// ```
    #[prost(bool, optional, tag = "1")]
    pub r#const: ::core::option::Option<bool>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyBool {
    ///    bool value = 1 [
    ///      (buf.validate.field).bool.example = 1,
    ///      (buf.validate.field).bool.example = 2
    ///    ];
    /// }
    /// ```
    #[prost(bool, repeated, packed = "false", tag = "2")]
    pub example: ::prost::alloc::vec::Vec<bool>,
}
/// StringRules describes the rules applied to `string` values These
/// rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringRules {
    /// `const` requires the field value to exactly match the specified value. If
    /// the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value must equal `hello`
    ///    string value = 1 \[(buf.validate.field).string.const = "hello"\];
    /// }
    /// ```
    #[prost(string, optional, tag = "1")]
    pub r#const: ::core::option::Option<::prost::alloc::string::String>,
    /// `len` dictates that the field value must have the specified
    /// number of characters (Unicode code points), which may differ from the number
    /// of bytes in the string. If the field value does not meet the specified
    /// length, an error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value length must be 5 characters
    ///    string value = 1 \[(buf.validate.field).string.len = 5\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "19")]
    pub len: ::core::option::Option<u64>,
    /// `min_len` specifies that the field value must have at least the specified
    /// number of characters (Unicode code points), which may differ from the number
    /// of bytes in the string. If the field value contains fewer characters, an error
    /// message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value length must be at least 3 characters
    ///    string value = 1 \[(buf.validate.field).string.min_len = 3\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "2")]
    pub min_len: ::core::option::Option<u64>,
    /// `max_len` specifies that the field value must have no more than the specified
    /// number of characters (Unicode code points), which may differ from the
    /// number of bytes in the string. If the field value contains more characters,
    /// an error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value length must be at most 10 characters
    ///    string value = 1 \[(buf.validate.field).string.max_len = 10\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "3")]
    pub max_len: ::core::option::Option<u64>,
    /// `len_bytes` dictates that the field value must have the specified number of
    /// bytes. If the field value does not match the specified length in bytes,
    /// an error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value length must be 6 bytes
    ///    string value = 1 \[(buf.validate.field).string.len_bytes = 6\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "20")]
    pub len_bytes: ::core::option::Option<u64>,
    /// `min_bytes` specifies that the field value must have at least the specified
    /// number of bytes. If the field value contains fewer bytes, an error message
    /// will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value length must be at least 4 bytes
    ///    string value = 1 \[(buf.validate.field).string.min_bytes = 4\];
    /// }
    ///
    /// ```
    #[prost(uint64, optional, tag = "4")]
    pub min_bytes: ::core::option::Option<u64>,
    /// `max_bytes` specifies that the field value must have no more than the
    /// specified number of bytes. If the field value contains more bytes, an
    /// error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value length must be at most 8 bytes
    ///    string value = 1 \[(buf.validate.field).string.max_bytes = 8\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "5")]
    pub max_bytes: ::core::option::Option<u64>,
    /// `pattern` specifies that the field value must match the specified
    /// regular expression (RE2 syntax), with the expression provided without any
    /// delimiters. If the field value doesn't match the regular expression, an
    /// error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value does not match regex pattern `^\[a-zA-Z\]//$`
    ///    string value = 1 \[(buf.validate.field).string.pattern = "^[a-zA-Z\]//$"];
    /// }
    /// ```
    #[prost(string, optional, tag = "6")]
    pub pattern: ::core::option::Option<::prost::alloc::string::String>,
    /// `prefix` specifies that the field value must have the
    /// specified substring at the beginning of the string. If the field value
    /// doesn't start with the specified prefix, an error message will be
    /// generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value does not have prefix `pre`
    ///    string value = 1 \[(buf.validate.field).string.prefix = "pre"\];
    /// }
    /// ```
    #[prost(string, optional, tag = "7")]
    pub prefix: ::core::option::Option<::prost::alloc::string::String>,
    /// `suffix` specifies that the field value must have the
    /// specified substring at the end of the string. If the field value doesn't
    /// end with the specified suffix, an error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value does not have suffix `post`
    ///    string value = 1 \[(buf.validate.field).string.suffix = "post"\];
    /// }
    /// ```
    #[prost(string, optional, tag = "8")]
    pub suffix: ::core::option::Option<::prost::alloc::string::String>,
    /// `contains` specifies that the field value must have the
    /// specified substring anywhere in the string. If the field value doesn't
    /// contain the specified substring, an error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value does not contain substring `inside`.
    ///    string value = 1 \[(buf.validate.field).string.contains = "inside"\];
    /// }
    /// ```
    #[prost(string, optional, tag = "9")]
    pub contains: ::core::option::Option<::prost::alloc::string::String>,
    /// `not_contains` specifies that the field value must not have the
    /// specified substring anywhere in the string. If the field value contains
    /// the specified substring, an error message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value contains substring `inside`.
    ///    string value = 1 \[(buf.validate.field).string.not_contains = "inside"\];
    /// }
    /// ```
    #[prost(string, optional, tag = "23")]
    pub not_contains: ::core::option::Option<::prost::alloc::string::String>,
    /// `in` specifies that the field value must be equal to one of the specified
    /// values. If the field value isn't one of the specified values, an error
    /// message will be generated.
    ///
    /// ```proto
    /// message MyString {
    ///    // value must be in list \["apple", "banana"\]
    ///    string value = 1 \[(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"\];
    /// }
    /// ```
    #[prost(string, repeated, tag = "10")]
    pub r#in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// `not_in` specifies that the field value cannot be equal to any
    /// of the specified values. If the field value is one of the specified values,
    /// an error message will be generated.
    /// ```proto
    /// message MyString {
    ///    // value must not be in list \["orange", "grape"\]
    ///    string value = 1 \[(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"\];
    /// }
    /// ```
    #[prost(string, repeated, tag = "11")]
    pub not_in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
    /// enable strict header validation. By default, this is true, and HTTP header
    /// validations are [RFC-compliant](<https://datatracker.ietf.org/doc/html/rfc7230#section-3>). Setting to false will enable looser
    /// validations that only disallow `\r\n\0` characters, which can be used to
    /// bypass header matching rules.
    ///
    /// ```proto
    /// message MyString {
    ///    // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
    ///    string value = 1 \[(buf.validate.field).string.strict = false\];
    /// }
    /// ```
    #[prost(bool, optional, tag = "25")]
    pub strict: ::core::option::Option<bool>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyString {
    ///    string value = 1 [
    ///      (buf.validate.field).string.example = "hello",
    ///      (buf.validate.field).string.example = "world"
    ///    ];
    /// }
    /// ```
    #[prost(string, repeated, tag = "34")]
    pub example: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// `WellKnown` rules provide advanced rules against common string
    /// patterns.
    #[prost(
        oneof = "string_rules::WellKnown",
        tags = "12, 13, 14, 15, 16, 17, 18, 21, 22, 33, 26, 27, 28, 29, 30, 31, 32, 24"
    )]
    pub well_known: ::core::option::Option<string_rules::WellKnown>,
}
/// Nested message and enum types in `StringRules`.
pub mod string_rules {
    /// `WellKnown` rules provide advanced rules against common string
    /// patterns.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum WellKnown {
        /// `email` specifies that the field value must be a valid email address, for
        /// example "foo@example.com".
        ///
        /// Conforms to the definition for a valid email address from the [HTML standard](<https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address>).
        /// Note that this standard willfully deviates from [RFC 5322](<https://datatracker.ietf.org/doc/html/rfc5322>),
        /// which allows many unexpected forms of email addresses and will easily match
        /// a typographical error.
        ///
        /// If the field value isn't a valid email address, an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid email address
        ///    string value = 1 \[(buf.validate.field).string.email = true\];
        /// }
        /// ```
        #[prost(bool, tag = "12")]
        Email(bool),
        /// `hostname` specifies that the field value must be a valid hostname, for
        /// example "foo.example.com".
        ///
        /// A valid hostname follows the rules below:
        /// - The name consists of one or more labels, separated by a dot (".").
        /// - Each label can be 1 to 63 alphanumeric characters.
        /// - A label can contain hyphens ("-"), but must not start or end with a hyphen.
        /// - The right-most label must not be digits only.
        /// - The name can have a trailing dot—for example, "foo.example.com.".
        /// - The name can be 253 characters at most, excluding the optional trailing dot.
        ///
        /// If the field value isn't a valid hostname, an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid hostname
        ///    string value = 1 \[(buf.validate.field).string.hostname = true\];
        /// }
        /// ```
        #[prost(bool, tag = "13")]
        Hostname(bool),
        /// `ip` specifies that the field value must be a valid IP (v4 or v6) address.
        ///
        /// IPv4 addresses are expected in the dotted decimal format—for example, "192.168.5.21".
        /// IPv6 addresses are expected in their text representation—for example, "::1",
        /// or "2001:0DB8:ABCD:0012::0".
        ///
        /// Both formats are well-defined in the internet standard [RFC 3986](<https://datatracker.ietf.org/doc/html/rfc3986>).
        /// Zone identifiers for IPv6 addresses (for example, "fe80::a%en1") are supported.
        ///
        /// If the field value isn't a valid IP address, an error message will be
        /// generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IP address
        ///    string value = 1 \[(buf.validate.field).string.ip = true\];
        /// }
        /// ```
        #[prost(bool, tag = "14")]
        Ip(bool),
        /// `ipv4` specifies that the field value must be a valid IPv4 address—for
        /// example "192.168.5.21". If the field value isn't a valid IPv4 address, an
        /// error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IPv4 address
        ///    string value = 1 \[(buf.validate.field).string.ipv4 = true\];
        /// }
        /// ```
        #[prost(bool, tag = "15")]
        Ipv4(bool),
        /// `ipv6` specifies that the field value must be a valid IPv6 address—for
        /// example "::1", or "d7a:115c:a1e0:ab12:4843:cd96:626b:430b". If the field
        /// value is not a valid IPv6 address, an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IPv6 address
        ///    string value = 1 \[(buf.validate.field).string.ipv6 = true\];
        /// }
        /// ```
        #[prost(bool, tag = "16")]
        Ipv6(bool),
        /// `uri` specifies that the field value must be a valid URI, for example
        /// "<https://example.com/foo/bar?baz=quux#frag".>
        ///
        /// URI is defined in the internet standard [RFC 3986](<https://datatracker.ietf.org/doc/html/rfc3986>).
        /// Zone Identifiers in IPv6 address literals are supported ([RFC 6874](<https://datatracker.ietf.org/doc/html/rfc6874>)).
        ///
        /// If the field value isn't a valid URI, an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid URI
        ///    string value = 1 \[(buf.validate.field).string.uri = true\];
        /// }
        /// ```
        #[prost(bool, tag = "17")]
        Uri(bool),
        /// `uri_ref` specifies that the field value must be a valid URI Reference—either
        /// a URI such as "<https://example.com/foo/bar?baz=quux#frag",> or a Relative
        /// Reference such as "./foo/bar?query".
        ///
        /// URI, URI Reference, and Relative Reference are defined in the internet
        /// standard [RFC 3986](<https://datatracker.ietf.org/doc/html/rfc3986>). Zone
        /// Identifiers in IPv6 address literals are supported ([RFC 6874](<https://datatracker.ietf.org/doc/html/rfc6874>)).
        ///
        /// If the field value isn't a valid URI Reference, an error message will be
        /// generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid URI Reference
        ///    string value = 1 \[(buf.validate.field).string.uri_ref = true\];
        /// }
        /// ```
        #[prost(bool, tag = "18")]
        UriRef(bool),
        /// `address` specifies that the field value must be either a valid hostname
        /// (for example, "example.com"), or a valid IP (v4 or v6) address (for example,
        /// "192.168.0.1", or "::1"). If the field value isn't a valid hostname or IP,
        /// an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid hostname, or ip address
        ///    string value = 1 \[(buf.validate.field).string.address = true\];
        /// }
        /// ```
        #[prost(bool, tag = "21")]
        Address(bool),
        /// `uuid` specifies that the field value must be a valid UUID as defined by
        /// [RFC 4122](<https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2>). If the
        /// field value isn't a valid UUID, an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid UUID
        ///    string value = 1 \[(buf.validate.field).string.uuid = true\];
        /// }
        /// ```
        #[prost(bool, tag = "22")]
        Uuid(bool),
        /// `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
        /// defined by [RFC 4122](<https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2>) with all dashes
        /// omitted. If the field value isn't a valid UUID without dashes, an error message
        /// will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid trimmed UUID
        ///    string value = 1 \[(buf.validate.field).string.tuuid = true\];
        /// }
        /// ```
        #[prost(bool, tag = "33")]
        Tuuid(bool),
        /// `ip_with_prefixlen` specifies that the field value must be a valid IP
        /// (v4 or v6) address with prefix length—for example, "192.168.5.21/16" or
        /// "2001:0DB8:ABCD:0012::F1/64". If the field value isn't a valid IP with
        /// prefix length, an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IP with prefix length
        ///     string value = 1 \[(buf.validate.field).string.ip_with_prefixlen = true\];
        /// }
        /// ```
        #[prost(bool, tag = "26")]
        IpWithPrefixlen(bool),
        /// `ipv4_with_prefixlen` specifies that the field value must be a valid
        /// IPv4 address with prefix length—for example, "192.168.5.21/16". If the
        /// field value isn't a valid IPv4 address with prefix length, an error
        /// message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IPv4 address with prefix length
        ///     string value = 1 \[(buf.validate.field).string.ipv4_with_prefixlen = true\];
        /// }
        /// ```
        #[prost(bool, tag = "27")]
        Ipv4WithPrefixlen(bool),
        /// `ipv6_with_prefixlen` specifies that the field value must be a valid
        /// IPv6 address with prefix length—for example, "2001:0DB8:ABCD:0012::F1/64".
        /// If the field value is not a valid IPv6 address with prefix length,
        /// an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IPv6 address prefix length
        ///     string value = 1 \[(buf.validate.field).string.ipv6_with_prefixlen = true\];
        /// }
        /// ```
        #[prost(bool, tag = "28")]
        Ipv6WithPrefixlen(bool),
        /// `ip_prefix` specifies that the field value must be a valid IP (v4 or v6)
        /// prefix—for example, "192.168.0.0/16" or "2001:0DB8:ABCD:0012::0/64".
        ///
        /// The prefix must have all zeros for the unmasked bits. For example,
        /// "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
        /// prefix, and the remaining 64 bits must be zero.
        ///
        /// If the field value isn't a valid IP prefix, an error message will be
        /// generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IP prefix
        ///     string value = 1 \[(buf.validate.field).string.ip_prefix = true\];
        /// }
        /// ```
        #[prost(bool, tag = "29")]
        IpPrefix(bool),
        /// `ipv4_prefix` specifies that the field value must be a valid IPv4
        /// prefix, for example "192.168.0.0/16".
        ///
        /// The prefix must have all zeros for the unmasked bits. For example,
        /// "192.168.0.0/16" designates the left-most 16 bits for the prefix,
        /// and the remaining 16 bits must be zero.
        ///
        /// If the field value isn't a valid IPv4 prefix, an error message
        /// will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IPv4 prefix
        ///     string value = 1 \[(buf.validate.field).string.ipv4_prefix = true\];
        /// }
        /// ```
        #[prost(bool, tag = "30")]
        Ipv4Prefix(bool),
        /// `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix—for
        /// example, "2001:0DB8:ABCD:0012::0/64".
        ///
        /// The prefix must have all zeros for the unmasked bits. For example,
        /// "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
        /// prefix, and the remaining 64 bits must be zero.
        ///
        /// If the field value is not a valid IPv6 prefix, an error message will be
        /// generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid IPv6 prefix
        ///     string value = 1 \[(buf.validate.field).string.ipv6_prefix = true\];
        /// }
        /// ```
        #[prost(bool, tag = "31")]
        Ipv6Prefix(bool),
        /// `host_and_port` specifies that the field value must be valid host/port
        /// pair—for example, "example.com:8080".
        ///
        /// The host can be one of:
        /// - An IPv4 address in dotted decimal format—for example, "192.168.5.21".
        /// - An IPv6 address enclosed in square brackets—for example, "\[2001:0DB8:ABCD:0012::F1\]".
        /// - A hostname—for example, "example.com".
        ///
        /// The port is separated by a colon. It must be non-empty, with a decimal number
        /// in the range of 0-65535, inclusive.
        #[prost(bool, tag = "32")]
        HostAndPort(bool),
        /// `well_known_regex` specifies a common well-known pattern
        /// defined as a regex. If the field value doesn't match the well-known
        /// regex, an error message will be generated.
        ///
        /// ```proto
        /// message MyString {
        ///    // value must be a valid HTTP header value
        ///    string value = 1 \[(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE\];
        /// }
        /// ```
        ///
        /// #### KnownRegex
        ///
        /// `well_known_regex` contains some well-known patterns.
        ///
        /// | Name                          | Number | Description                               |
        /// |-------------------------------|--------|-------------------------------------------|
        /// | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
        /// | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](<https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>)  |
        /// | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](<https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4>) |
        #[prost(enumeration = "super::KnownRegex", tag = "24")]
        WellKnownRegex(i32),
    }
}
/// BytesRules describe the rules applied to `bytes` values. These rules
/// may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BytesRules {
    /// `const` requires the field value to exactly match the specified bytes
    /// value. If the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value must be "\x01\x02\x03\x04"
    ///    bytes value = 1 \[(buf.validate.field).bytes.const = "\x01\x02\x03\x04"\];
    /// }
    /// ```
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub r#const: ::core::option::Option<::prost::bytes::Bytes>,
    /// `len` requires the field value to have the specified length in bytes.
    /// If the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value length must be 4 bytes.
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.len = 4\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "13")]
    pub len: ::core::option::Option<u64>,
    /// `min_len` requires the field value to have at least the specified minimum
    /// length in bytes.
    /// If the field value doesn't meet the requirement, an error message is generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value length must be at least 2 bytes.
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.min_len = 2\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "2")]
    pub min_len: ::core::option::Option<u64>,
    /// `max_len` requires the field value to have at most the specified maximum
    /// length in bytes.
    /// If the field value exceeds the requirement, an error message is generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value must be at most 6 bytes.
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.max_len = 6\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "3")]
    pub max_len: ::core::option::Option<u64>,
    /// `pattern` requires the field value to match the specified regular
    /// expression ([RE2 syntax](<https://github.com/google/re2/wiki/Syntax>)).
    /// The value of the field must be valid UTF-8 or validation will fail with a
    /// runtime error.
    /// If the field value doesn't match the pattern, an error message is generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value must match regex pattern "^\[a-zA-Z0-9\]+$".
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9\]+$"];
    /// }
    /// ```
    #[prost(string, optional, tag = "4")]
    pub pattern: ::core::option::Option<::prost::alloc::string::String>,
    /// `prefix` requires the field value to have the specified bytes at the
    /// beginning of the string.
    /// If the field value doesn't meet the requirement, an error message is generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value does not have prefix \x01\x02
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.prefix = "\x01\x02"\];
    /// }
    /// ```
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub prefix: ::core::option::Option<::prost::bytes::Bytes>,
    /// `suffix` requires the field value to have the specified bytes at the end
    /// of the string.
    /// If the field value doesn't meet the requirement, an error message is generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value does not have suffix \x03\x04
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.suffix = "\x03\x04"\];
    /// }
    /// ```
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub suffix: ::core::option::Option<::prost::bytes::Bytes>,
    /// `contains` requires the field value to have the specified bytes anywhere in
    /// the string.
    /// If the field value doesn't meet the requirement, an error message is generated.
    ///
    /// ```protobuf
    /// message MyBytes {
    ///    // value does not contain \x02\x03
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.contains = "\x02\x03"\];
    /// }
    /// ```
    #[prost(bytes = "bytes", optional, tag = "7")]
    pub contains: ::core::option::Option<::prost::bytes::Bytes>,
    /// `in` requires the field value to be equal to one of the specified
    /// values. If the field value doesn't match any of the specified values, an
    /// error message is generated.
    ///
    /// ```protobuf
    /// message MyBytes {
    ///    // value must in \["\x01\x02", "\x02\x03", "\x03\x04"\]
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}\];
    /// }
    /// ```
    #[prost(bytes = "bytes", repeated, tag = "8")]
    pub r#in: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// `not_in` requires the field value to be not equal to any of the specified
    /// values.
    /// If the field value matches any of the specified values, an error message is
    /// generated.
    ///
    /// ```proto
    /// message MyBytes {
    ///    // value must not in \["\x01\x02", "\x02\x03", "\x03\x04"\]
    ///    optional bytes value = 1 \[(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}\];
    /// }
    /// ```
    #[prost(bytes = "bytes", repeated, tag = "9")]
    pub not_in: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyBytes {
    ///    bytes value = 1 [
    ///      (buf.validate.field).bytes.example = "\x01\x02",
    ///      (buf.validate.field).bytes.example = "\x02\x03"
    ///    ];
    /// }
    /// ```
    #[prost(bytes = "bytes", repeated, tag = "14")]
    pub example: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// WellKnown rules provide advanced rules against common byte
    /// patterns
    #[prost(oneof = "bytes_rules::WellKnown", tags = "10, 11, 12")]
    pub well_known: ::core::option::Option<bytes_rules::WellKnown>,
}
/// Nested message and enum types in `BytesRules`.
pub mod bytes_rules {
    /// WellKnown rules provide advanced rules against common byte
    /// patterns
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum WellKnown {
        /// `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
        /// If the field value doesn't meet this rule, an error message is generated.
        ///
        /// ```proto
        /// message MyBytes {
        ///    // value must be a valid IP address
        ///    optional bytes value = 1 \[(buf.validate.field).bytes.ip = true\];
        /// }
        /// ```
        #[prost(bool, tag = "10")]
        Ip(bool),
        /// `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
        /// If the field value doesn't meet this rule, an error message is generated.
        ///
        /// ```proto
        /// message MyBytes {
        ///    // value must be a valid IPv4 address
        ///    optional bytes value = 1 \[(buf.validate.field).bytes.ipv4 = true\];
        /// }
        /// ```
        #[prost(bool, tag = "11")]
        Ipv4(bool),
        /// `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
        /// If the field value doesn't meet this rule, an error message is generated.
        /// ```proto
        /// message MyBytes {
        ///    // value must be a valid IPv6 address
        ///    optional bytes value = 1 \[(buf.validate.field).bytes.ipv6 = true\];
        /// }
        /// ```
        #[prost(bool, tag = "12")]
        Ipv6(bool),
    }
}
/// EnumRules describe the rules applied to `enum` values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnumRules {
    /// `const` requires the field value to exactly match the specified enum value.
    /// If the field value doesn't match, an error message is generated.
    ///
    /// ```proto
    /// enum MyEnum {
    ///    MY_ENUM_UNSPECIFIED = 0;
    ///    MY_ENUM_VALUE1 = 1;
    ///    MY_ENUM_VALUE2 = 2;
    /// }
    ///
    /// message MyMessage {
    ///    // The field `value` must be exactly MY_ENUM_VALUE1.
    ///    MyEnum value = 1 \[(buf.validate.field).enum.const = 1\];
    /// }
    /// ```
    #[prost(int32, optional, tag = "1")]
    pub r#const: ::core::option::Option<i32>,
    /// `defined_only` requires the field value to be one of the defined values for
    /// this enum, failing on any undefined value.
    ///
    /// ```proto
    /// enum MyEnum {
    ///    MY_ENUM_UNSPECIFIED = 0;
    ///    MY_ENUM_VALUE1 = 1;
    ///    MY_ENUM_VALUE2 = 2;
    /// }
    ///
    /// message MyMessage {
    ///    // The field `value` must be a defined value of MyEnum.
    ///    MyEnum value = 1 \[(buf.validate.field).enum.defined_only = true\];
    /// }
    /// ```
    #[prost(bool, optional, tag = "2")]
    pub defined_only: ::core::option::Option<bool>,
    /// `in` requires the field value to be equal to one of the
    /// specified enum values. If the field value doesn't match any of the
    /// specified values, an error message is generated.
    ///
    /// ```proto
    /// enum MyEnum {
    ///    MY_ENUM_UNSPECIFIED = 0;
    ///    MY_ENUM_VALUE1 = 1;
    ///    MY_ENUM_VALUE2 = 2;
    /// }
    ///
    /// message MyMessage {
    ///    // The field `value` must be equal to one of the specified values.
    ///    MyEnum value = 1 \[(buf.validate.field).enum = { in: [1, 2\]}];
    /// }
    /// ```
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    /// `not_in` requires the field value to be not equal to any of the
    /// specified enum values. If the field value matches one of the specified
    /// values, an error message is generated.
    ///
    /// ```proto
    /// enum MyEnum {
    ///    MY_ENUM_UNSPECIFIED = 0;
    ///    MY_ENUM_VALUE1 = 1;
    ///    MY_ENUM_VALUE2 = 2;
    /// }
    ///
    /// message MyMessage {
    ///    // The field `value` must not be equal to any of the specified values.
    ///    MyEnum value = 1 \[(buf.validate.field).enum = { not_in: [1, 2\]}];
    /// }
    /// ```
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// enum MyEnum {
    ///    MY_ENUM_UNSPECIFIED = 0;
    ///    MY_ENUM_VALUE1 = 1;
    ///    MY_ENUM_VALUE2 = 2;
    /// }
    ///
    /// message MyMessage {
    ///      (buf.validate.field).enum.example = 1,
    ///      (buf.validate.field).enum.example = 2
    /// }
    /// ```
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub example: ::prost::alloc::vec::Vec<i32>,
}
/// RepeatedRules describe the rules applied to `repeated` values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepeatedRules {
    /// `min_items` requires that this field must contain at least the specified
    /// minimum number of items.
    ///
    /// Note that `min_items = 1` is equivalent to setting a field as `required`.
    ///
    /// ```proto
    /// message MyRepeated {
    ///    // value must contain at least  2 items
    ///    repeated string value = 1 \[(buf.validate.field).repeated.min_items = 2\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "1")]
    pub min_items: ::core::option::Option<u64>,
    /// `max_items` denotes that this field must not exceed a
    /// certain number of items as the upper limit. If the field contains more
    /// items than specified, an error message will be generated, requiring the
    /// field to maintain no more than the specified number of items.
    ///
    /// ```proto
    /// message MyRepeated {
    ///    // value must contain no more than 3 item(s)
    ///    repeated string value = 1 \[(buf.validate.field).repeated.max_items = 3\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "2")]
    pub max_items: ::core::option::Option<u64>,
    /// `unique` indicates that all elements in this field must
    /// be unique. This rule is strictly applicable to scalar and enum
    /// types, with message types not being supported.
    ///
    /// ```proto
    /// message MyRepeated {
    ///    // repeated value must contain unique items
    ///    repeated string value = 1 \[(buf.validate.field).repeated.unique = true\];
    /// }
    /// ```
    #[prost(bool, optional, tag = "3")]
    pub unique: ::core::option::Option<bool>,
    /// `items` details the rules to be applied to each item
    /// in the field. Even for repeated message fields, validation is executed
    /// against each item unless `ignore` is specified.
    ///
    /// ```proto
    /// message MyRepeated {
    ///    // The items in the field `value` must follow the specified rules.
    ///    repeated string value = 1 [(buf.validate.field).repeated.items = {
    ///      string: {
    ///        min_len: 3
    ///        max_len: 10
    ///      }
    ///    }];
    /// }
    /// ```
    ///
    /// Note that the `required` rule does not apply. Repeated items
    /// cannot be unset.
    #[prost(message, optional, boxed, tag = "4")]
    pub items: ::core::option::Option<::prost::alloc::boxed::Box<FieldRules>>,
}
/// MapRules describe the rules applied to `map` values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapRules {
    /// Specifies the minimum number of key-value pairs allowed. If the field has
    /// fewer key-value pairs than specified, an error message is generated.
    ///
    /// ```proto
    /// message MyMap {
    ///    // The field `value` must have at least 2 key-value pairs.
    ///    map<string, string> value = 1 \[(buf.validate.field).map.min_pairs = 2\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "1")]
    pub min_pairs: ::core::option::Option<u64>,
    /// Specifies the maximum number of key-value pairs allowed. If the field has
    /// more key-value pairs than specified, an error message is generated.
    ///
    /// ```proto
    /// message MyMap {
    ///    // The field `value` must have at most 3 key-value pairs.
    ///    map<string, string> value = 1 \[(buf.validate.field).map.max_pairs = 3\];
    /// }
    /// ```
    #[prost(uint64, optional, tag = "2")]
    pub max_pairs: ::core::option::Option<u64>,
    /// Specifies the rules to be applied to each key in the field.
    ///
    /// ```proto
    /// message MyMap {
    ///    // The keys in the field `value` must follow the specified rules.
    ///    map<string, string> value = 1 [(buf.validate.field).map.keys = {
    ///      string: {
    ///        min_len: 3
    ///        max_len: 10
    ///      }
    ///    }];
    /// }
    /// ```
    ///
    /// Note that the `required` rule does not apply. Map keys cannot be unset.
    #[prost(message, optional, boxed, tag = "4")]
    pub keys: ::core::option::Option<::prost::alloc::boxed::Box<FieldRules>>,
    /// Specifies the rules to be applied to the value of each key in the
    /// field. Message values will still have their validations evaluated unless
    /// `ignore` is specified.
    ///
    /// ```proto
    /// message MyMap {
    ///    // The values in the field `value` must follow the specified rules.
    ///    map<string, string> value = 1 [(buf.validate.field).map.values = {
    ///      string: {
    ///        min_len: 5
    ///        max_len: 20
    ///      }
    ///    }];
    /// }
    /// ```
    /// Note that the `required` rule does not apply. Map values cannot be unset.
    #[prost(message, optional, boxed, tag = "5")]
    pub values: ::core::option::Option<::prost::alloc::boxed::Box<FieldRules>>,
}
/// AnyRules describe rules applied exclusively to the `google.protobuf.Any` well-known type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnyRules {
    /// `in` requires the field's `type_url` to be equal to one of the
    /// specified values. If it doesn't match any of the specified values, an error
    /// message is generated.
    ///
    /// ```proto
    /// message MyAny {
    ///    //  The `value` field must have a `type_url` equal to one of the specified values.
    ///    google.protobuf.Any value = 1 [(buf.validate.field).any = {
    ///        in: \["type.googleapis.com/MyType1", "type.googleapis.com/MyType2"\]
    ///    }];
    /// }
    /// ```
    #[prost(string, repeated, tag = "2")]
    pub r#in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.
    ///
    /// ```proto
    /// message MyAny {
    ///    //  The `value` field must not have a `type_url` equal to any of the specified values.
    ///    google.protobuf.Any value = 1 [(buf.validate.field).any = {
    ///        not_in: \["type.googleapis.com/ForbiddenType1", "type.googleapis.com/ForbiddenType2"\]
    ///    }];
    /// }
    /// ```
    #[prost(string, repeated, tag = "3")]
    pub not_in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// DurationRules describe the rules applied exclusively to the `google.protobuf.Duration` well-known type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DurationRules {
    /// `const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.
    /// If the field's value deviates from the specified value, an error message
    /// will be generated.
    ///
    /// ```proto
    /// message MyDuration {
    ///    // value must equal 5s
    ///    google.protobuf.Duration value = 1 \[(buf.validate.field).duration.const = "5s"\];
    /// }
    /// ```
    #[prost(message, optional, tag = "2")]
    pub r#const: ::core::option::Option<crate::protobuf::Duration>,
    /// `in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.
    /// If the field's value doesn't correspond to any of the specified values,
    /// an error message will be generated.
    ///
    /// ```proto
    /// message MyDuration {
    ///    // value must be in list \[1s, 2s, 3s\]
    ///    google.protobuf.Duration value = 1 \[(buf.validate.field).duration.in = ["1s", "2s", "3s"]\];
    /// }
    /// ```
    #[prost(message, repeated, tag = "7")]
    pub r#in: ::prost::alloc::vec::Vec<crate::protobuf::Duration>,
    /// `not_in` denotes that the field must not be equal to
    /// any of the specified values of the `google.protobuf.Duration` type.
    /// If the field's value matches any of these values, an error message will be
    /// generated.
    ///
    /// ```proto
    /// message MyDuration {
    ///    // value must not be in list \[1s, 2s, 3s\]
    ///    google.protobuf.Duration value = 1 \[(buf.validate.field).duration.not_in = ["1s", "2s", "3s"]\];
    /// }
    /// ```
    #[prost(message, repeated, tag = "8")]
    pub not_in: ::prost::alloc::vec::Vec<crate::protobuf::Duration>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyDuration {
    ///    google.protobuf.Duration value = 1 [
    ///      (buf.validate.field).duration.example = { seconds: 1 },
    ///      (buf.validate.field).duration.example = { seconds: 2 },
    ///    ];
    /// }
    /// ```
    #[prost(message, repeated, tag = "9")]
    pub example: ::prost::alloc::vec::Vec<crate::protobuf::Duration>,
    #[prost(oneof = "duration_rules::LessThan", tags = "3, 4")]
    pub less_than: ::core::option::Option<duration_rules::LessThan>,
    #[prost(oneof = "duration_rules::GreaterThan", tags = "5, 6")]
    pub greater_than: ::core::option::Option<duration_rules::GreaterThan>,
}
/// Nested message and enum types in `DurationRules`.
pub mod duration_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// `lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,
        /// exclusive. If the field's value is greater than or equal to the specified
        /// value, an error message will be generated.
        ///
        /// ```proto
        /// message MyDuration {
        ///    // value must be less than 5s
        ///    google.protobuf.Duration value = 1 \[(buf.validate.field).duration.lt = "5s"\];
        /// }
        /// ```
        #[prost(message, tag = "3")]
        Lt(crate::protobuf::Duration),
        /// `lte` indicates that the field must be less than or equal to the specified
        /// value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,
        /// an error message will be generated.
        ///
        /// ```proto
        /// message MyDuration {
        ///    // value must be less than or equal to 10s
        ///    google.protobuf.Duration value = 1 \[(buf.validate.field).duration.lte = "10s"\];
        /// }
        /// ```
        #[prost(message, tag = "4")]
        Lte(crate::protobuf::Duration),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the duration field value to be greater than the specified
        /// value (exclusive). If the value of `gt` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyDuration {
        ///    // duration must be greater than 5s \[duration.gt\]
        ///    google.protobuf.Duration value = 1 \[(buf.validate.field).duration.gt = { seconds: 5 }\];
        ///
        ///    // duration must be greater than 5s and less than 10s \[duration.gt_lt\]
        ///    google.protobuf.Duration another_value = 2 \[(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }\];
        ///
        ///    // duration must be greater than 10s or less than 5s \[duration.gt_lt_exclusive\]
        ///    google.protobuf.Duration other_value = 3 \[(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }\];
        /// }
        /// ```
        #[prost(message, tag = "5")]
        Gt(crate::protobuf::Duration),
        /// `gte` requires the duration field value to be greater than or equal to the
        /// specified value (exclusive). If the value of `gte` is larger than a
        /// specified `lt` or `lte`, the range is reversed, and the field value must
        /// be outside the specified range. If the field value doesn't meet the
        /// required conditions, an error message is generated.
        ///
        /// ```proto
        /// message MyDuration {
        ///   // duration must be greater than or equal to 5s \[duration.gte\]
        ///   google.protobuf.Duration value = 1 \[(buf.validate.field).duration.gte = { seconds: 5 }\];
        ///
        ///   // duration must be greater than or equal to 5s and less than 10s \[duration.gte_lt\]
        ///   google.protobuf.Duration another_value = 2 \[(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }\];
        ///
        ///   // duration must be greater than or equal to 10s or less than 5s \[duration.gte_lt_exclusive\]
        ///   google.protobuf.Duration other_value = 3 \[(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }\];
        /// }
        /// ```
        #[prost(message, tag = "6")]
        Gte(crate::protobuf::Duration),
    }
}
/// TimestampRules describe the rules applied exclusively to the `google.protobuf.Timestamp` well-known type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimestampRules {
    /// `const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.
    ///
    /// ```proto
    /// message MyTimestamp {
    ///    // value must equal 2023-05-03T10:00:00Z
    ///    google.protobuf.Timestamp created_at = 1 \[(buf.validate.field).timestamp.const = {seconds: 1727998800}\];
    /// }
    /// ```
    #[prost(message, optional, tag = "2")]
    pub r#const: ::core::option::Option<crate::protobuf::Timestamp>,
    /// `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.
    ///
    /// ```proto
    /// message MyTimestamp {
    ///    // value must be within 1 hour of now
    ///    google.protobuf.Timestamp created_at = 1 \[(buf.validate.field).timestamp.within = {seconds: 3600}\];
    /// }
    /// ```
    #[prost(message, optional, tag = "9")]
    pub within: ::core::option::Option<crate::protobuf::Duration>,
    /// `example` specifies values that the field may have. These values SHOULD
    /// conform to other rules. `example` values will not impact validation
    /// but may be used as helpful guidance on how to populate the given field.
    ///
    /// ```proto
    /// message MyTimestamp {
    ///    google.protobuf.Timestamp value = 1 [
    ///      (buf.validate.field).timestamp.example = { seconds: 1672444800 },
    ///      (buf.validate.field).timestamp.example = { seconds: 1672531200 },
    ///    ];
    /// }
    /// ```
    #[prost(message, repeated, tag = "10")]
    pub example: ::prost::alloc::vec::Vec<crate::protobuf::Timestamp>,
    #[prost(oneof = "timestamp_rules::LessThan", tags = "3, 4, 7")]
    pub less_than: ::core::option::Option<timestamp_rules::LessThan>,
    #[prost(oneof = "timestamp_rules::GreaterThan", tags = "5, 6, 8")]
    pub greater_than: ::core::option::Option<timestamp_rules::GreaterThan>,
}
/// Nested message and enum types in `TimestampRules`.
pub mod timestamp_rules {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum LessThan {
        /// requires the duration field value to be less than the specified value (field < value). If the field value doesn't meet the required conditions, an error message is generated.
        ///
        /// ```proto
        /// message MyDuration {
        ///    // duration must be less than 'P3D' \[duration.lt\]
        ///    google.protobuf.Duration value = 1 \[(buf.validate.field).duration.lt = { seconds: 259200 }\];
        /// }
        /// ```
        #[prost(message, tag = "3")]
        Lt(crate::protobuf::Timestamp),
        /// requires the timestamp field value to be less than or equal to the specified value (field <= value). If the field value doesn't meet the required conditions, an error message is generated.
        ///
        /// ```proto
        /// message MyTimestamp {
        ///    // timestamp must be less than or equal to '2023-05-14T00:00:00Z' \[timestamp.lte\]
        ///    google.protobuf.Timestamp value = 1 \[(buf.validate.field).timestamp.lte = { seconds: 1678867200 }\];
        /// }
        /// ```
        #[prost(message, tag = "4")]
        Lte(crate::protobuf::Timestamp),
        /// `lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.
        ///
        /// ```proto
        /// message MyTimestamp {
        ///   // value must be less than now
        ///    google.protobuf.Timestamp created_at = 1 \[(buf.validate.field).timestamp.lt_now = true\];
        /// }
        /// ```
        #[prost(bool, tag = "7")]
        LtNow(bool),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum GreaterThan {
        /// `gt` requires the timestamp field value to be greater than the specified
        /// value (exclusive). If the value of `gt` is larger than a specified `lt`
        /// or `lte`, the range is reversed, and the field value must be outside the
        /// specified range. If the field value doesn't meet the required conditions,
        /// an error message is generated.
        ///
        /// ```proto
        /// message MyTimestamp {
        ///    // timestamp must be greater than '2023-01-01T00:00:00Z' \[timestamp.gt\]
        ///    google.protobuf.Timestamp value = 1 \[(buf.validate.field).timestamp.gt = { seconds: 1672444800 }\];
        ///
        ///    // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' \[timestamp.gt_lt\]
        ///    google.protobuf.Timestamp another_value = 2 \[(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }\];
        ///
        ///    // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' \[timestamp.gt_lt_exclusive\]
        ///    google.protobuf.Timestamp other_value = 3 \[(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }\];
        /// }
        /// ```
        #[prost(message, tag = "5")]
        Gt(crate::protobuf::Timestamp),
        /// `gte` requires the timestamp field value to be greater than or equal to the
        /// specified value (exclusive). If the value of `gte` is larger than a
        /// specified `lt` or `lte`, the range is reversed, and the field value
        /// must be outside the specified range. If the field value doesn't meet
        /// the required conditions, an error message is generated.
        ///
        /// ```proto
        /// message MyTimestamp {
        ///    // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' \[timestamp.gte\]
        ///    google.protobuf.Timestamp value = 1 \[(buf.validate.field).timestamp.gte = { seconds: 1672444800 }\];
        ///
        ///    // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' \[timestamp.gte_lt\]
        ///    google.protobuf.Timestamp another_value = 2 \[(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }\];
        ///
        ///    // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' \[timestamp.gte_lt_exclusive\]
        ///    google.protobuf.Timestamp other_value = 3 \[(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }\];
        /// }
        /// ```
        #[prost(message, tag = "6")]
        Gte(crate::protobuf::Timestamp),
        /// `gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.
        ///
        /// ```proto
        /// message MyTimestamp {
        ///    // value must be greater than now
        ///    google.protobuf.Timestamp created_at = 1 \[(buf.validate.field).timestamp.gt_now = true\];
        /// }
        /// ```
        #[prost(bool, tag = "8")]
        GtNow(bool),
    }
}
/// `Violations` is a collection of `Violation` messages. This message type is returned by
/// Protovalidate when a proto message fails to meet the requirements set by the `Rule` validation rules.
/// Each individual violation is represented by a `Violation` message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Violations {
    /// `violations` is a repeated field that contains all the `Violation` messages corresponding to the violations detected.
    #[prost(message, repeated, tag = "1")]
    pub violations: ::prost::alloc::vec::Vec<Violation>,
}
/// `Violation` represents a single instance where a validation rule, expressed
/// as a `Rule`, was not met. It provides information about the field that
/// caused the violation, the specific rule that wasn't fulfilled, and a
/// human-readable error message.
///
/// For example, consider the following message:
///
/// ```proto
/// message User {
///      int32 age = 1 [(buf.validate.field).cel = {
///          id: "user.age",
///          expression: "this < 18 ? 'User must be at least 18 years old' : ''",
///      }];
/// }
/// ```
///
/// It could produce the following violation:
///
/// ```json
/// {
///    "ruleId": "user.age",
///    "message": "User must be at least 18 years old",
///    "field": {
///      "elements": [
///        {
///          "fieldNumber": 1,
///          "fieldName": "age",
///          "fieldType": "TYPE_INT32"
///        }
///      ]
///    },
///    "rule": {
///      "elements": [
///        {
///          "fieldNumber": 23,
///          "fieldName": "cel",
///          "fieldType": "TYPE_MESSAGE",
///          "index": "0"
///        }
///      ]
///    }
/// }
/// ```
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Violation {
    /// `field` is a machine-readable path to the field that failed validation.
    /// This could be a nested field, in which case the path will include all the parent fields leading to the actual field that caused the violation.
    ///
    /// For example, consider the following message:
    ///
    /// ```proto
    /// message Message {
    ///    bool a = 1 \[(buf.validate.field).required = true\];
    /// }
    /// ```
    ///
    /// It could produce the following violation:
    ///
    /// ```textproto
    /// violation {
    ///    field { element { field_number: 1, field_name: "a", field_type: 8 } }
    ///    ...
    /// }
    /// ```
    #[prost(message, optional, tag = "5")]
    pub field: ::core::option::Option<FieldPath>,
    /// `rule` is a machine-readable path that points to the specific rule that failed validation.
    /// This will be a nested field starting from the FieldRules of the field that failed validation.
    /// For custom rules, this will provide the path of the rule, e.g. `cel\[0\]`.
    ///
    /// For example, consider the following message:
    ///
    /// ```proto
    /// message Message {
    ///    bool a = 1 \[(buf.validate.field).required = true\];
    ///    bool b = 2 [(buf.validate.field).cel = {
    ///      id: "custom_rule",
    ///      expression: "!this ? 'b must be true': ''"
    ///    }]
    /// }
    /// ```
    ///
    /// It could produce the following violations:
    ///
    /// ```textproto
    /// violation {
    ///    rule { element { field_number: 25, field_name: "required", field_type: 8 } }
    ///    ...
    /// }
    /// violation {
    ///    rule { element { field_number: 23, field_name: "cel", field_type: 11, index: 0 } }
    ///    ...
    /// }
    /// ```
    #[prost(message, optional, tag = "6")]
    pub rule: ::core::option::Option<FieldPath>,
    /// `rule_id` is the unique identifier of the `Rule` that was not fulfilled.
    /// This is the same `id` that was specified in the `Rule` message, allowing easy tracing of which rule was violated.
    #[prost(string, optional, tag = "2")]
    pub rule_id: ::core::option::Option<::prost::alloc::string::String>,
    /// `message` is a human-readable error message that describes the nature of the violation.
    /// This can be the default error message from the violated `Rule`, or it can be a custom message that gives more context about the violation.
    #[prost(string, optional, tag = "3")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// `for_key` indicates whether the violation was caused by a map key, rather than a value.
    #[prost(bool, optional, tag = "4")]
    pub for_key: ::core::option::Option<bool>,
}
/// `FieldPath` provides a path to a nested protobuf field.
///
/// This message provides enough information to render a dotted field path even without protobuf descriptors.
/// It also provides enough information to resolve a nested field through unknown wire data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldPath {
    /// `elements` contains each element of the path, starting from the root and recursing downward.
    #[prost(message, repeated, tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<FieldPathElement>,
}
/// `FieldPathElement` provides enough information to nest through a single protobuf field.
///
/// If the selected field is a map or repeated field, the `subscript` value selects a specific element from it.
/// A path that refers to a value nested under a map key or repeated field index will have a `subscript` value.
/// The `field_type` field allows unambiguous resolution of a field even if descriptors are not available.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FieldPathElement {
    /// `field_number` is the field number this path element refers to.
    #[prost(int32, optional, tag = "1")]
    pub field_number: ::core::option::Option<i32>,
    /// `field_name` contains the field name this path element refers to.
    /// This can be used to display a human-readable path even if the field number is unknown.
    #[prost(string, optional, tag = "2")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    /// `field_type` specifies the type of this field. When using reflection, this value is not needed.
    ///
    /// This value is provided to make it possible to traverse unknown fields through wire data.
    /// When traversing wire data, be mindful of both packed\[1\] and delimited\[2\] encoding schemes.
    ///
    /// \[1\]: <https://protobuf.dev/programming-guides/encoding/#packed>
    /// \[2\]: <https://protobuf.dev/programming-guides/encoding/#groups>
    ///
    /// N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
    /// can be explicitly used in Protocol Buffers 2023 Edition.
    #[prost(
        enumeration = "crate::protobuf::field_descriptor_proto::Type",
        optional,
        tag = "3"
    )]
    pub field_type: ::core::option::Option<i32>,
    /// `key_type` specifies the map key type of this field. This value is useful when traversing
    /// unknown fields through wire data: specifically, it allows handling the differences between
    /// different integer encodings.
    #[prost(
        enumeration = "crate::protobuf::field_descriptor_proto::Type",
        optional,
        tag = "4"
    )]
    pub key_type: ::core::option::Option<i32>,
    /// `value_type` specifies map value type of this field. This is useful if you want to display a
    /// value inside unknown fields through wire data.
    #[prost(
        enumeration = "crate::protobuf::field_descriptor_proto::Type",
        optional,
        tag = "5"
    )]
    pub value_type: ::core::option::Option<i32>,
    /// `subscript` contains a repeated index or map key, if this path element nests into a repeated or map field.
    #[prost(oneof = "field_path_element::Subscript", tags = "6, 7, 8, 9, 10")]
    pub subscript: ::core::option::Option<field_path_element::Subscript>,
}
/// Nested message and enum types in `FieldPathElement`.
pub mod field_path_element {
    /// `subscript` contains a repeated index or map key, if this path element nests into a repeated or map field.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Subscript {
        /// `index` specifies a 0-based index into a repeated field.
        #[prost(uint64, tag = "6")]
        Index(u64),
        /// `bool_key` specifies a map key of type bool.
        #[prost(bool, tag = "7")]
        BoolKey(bool),
        /// `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
        #[prost(int64, tag = "8")]
        IntKey(i64),
        /// `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
        #[prost(uint64, tag = "9")]
        UintKey(u64),
        /// `string_key` specifies a map key of type string.
        #[prost(string, tag = "10")]
        StringKey(::prost::alloc::string::String),
    }
}
/// Specifies how `FieldRules.ignore` behaves, depending on the field's value, and
/// whether the field tracks presence.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Ignore {
    /// Ignore rules if the field tracks presence and is unset. This is the default
    /// behavior.
    ///
    /// In proto3, only message fields, members of a Protobuf `oneof`, and fields
    /// with the `optional` label track presence. Consequently, the following fields
    /// are always validated, whether a value is set or not:
    ///
    /// ```proto
    /// syntax="proto3";
    ///
    /// message RulesApply {
    ///    string email = 1 [
    ///      (buf.validate.field).string.email = true
    ///    ];
    ///    int32 age = 2 [
    ///      (buf.validate.field).int32.gt = 0
    ///    ];
    ///    repeated string labels = 3 [
    ///      (buf.validate.field).repeated.min_items = 1
    ///    ];
    /// }
    /// ```
    ///
    /// In contrast, the following fields track presence, and are only validated if
    /// a value is set:
    ///
    /// ```proto
    /// syntax="proto3";
    ///
    /// message RulesApplyIfSet {
    ///    optional string email = 1 [
    ///      (buf.validate.field).string.email = true
    ///    ];
    ///    oneof ref {
    ///      string reference = 2 [
    ///        (buf.validate.field).string.uuid = true
    ///      ];
    ///      string name = 3 [
    ///        (buf.validate.field).string.min_len = 4
    ///      ];
    ///    }
    ///    SomeMessage msg = 4 [
    ///      (buf.validate.field).cel = {/* ... */}
    ///    ];
    /// }
    /// ```
    ///
    /// To ensure that such a field is set, add the `required` rule.
    ///
    /// To learn which fields track presence, see the
    /// [Field Presence cheat sheet](<https://protobuf.dev/programming-guides/field_presence/#cheat>).
    Unspecified = 0,
    /// Ignore rules if the field is unset, or set to the zero value.
    ///
    /// The zero value depends on the field type:
    /// - For strings, the zero value is the empty string.
    /// - For bytes, the zero value is empty bytes.
    /// - For bool, the zero value is false.
    /// - For numeric types, the zero value is zero.
    /// - For enums, the zero value is the first defined enum value.
    /// - For repeated fields, the zero is an empty list.
    /// - For map fields, the zero is an empty map.
    /// - For message fields, absence of the message (typically a null-value) is considered zero value.
    ///
    /// For fields that track presence (e.g. adding the `optional` label in proto3),
    /// this a no-op and behavior is the same as the default `IGNORE_UNSPECIFIED`.
    IfZeroValue = 1,
    /// Always ignore rules, including the `required` rule.
    ///
    /// This is useful for ignoring the rules of a referenced message, or to
    /// temporarily ignore rules during development.
    ///
    /// ```proto
    /// message MyMessage {
    ///    // The field's rules will always be ignored, including any validations
    ///    // on value's fields.
    ///    MyOtherMessage value = 1 [
    ///      (buf.validate.field).ignore = IGNORE_ALWAYS];
    /// }
    /// ```
    Always = 3,
}
impl Ignore {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "IGNORE_UNSPECIFIED",
            Self::IfZeroValue => "IGNORE_IF_ZERO_VALUE",
            Self::Always => "IGNORE_ALWAYS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IGNORE_UNSPECIFIED" => Some(Self::Unspecified),
            "IGNORE_IF_ZERO_VALUE" => Some(Self::IfZeroValue),
            "IGNORE_ALWAYS" => Some(Self::Always),
            _ => None,
        }
    }
}
/// KnownRegex contains some well-known patterns.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KnownRegex {
    Unspecified = 0,
    /// HTTP header name as defined by [RFC 7230](<https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>).
    HttpHeaderName = 1,
    /// HTTP header value as defined by [RFC 7230](<https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4>).
    HttpHeaderValue = 2,
}
impl KnownRegex {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KNOWN_REGEX_UNSPECIFIED",
            Self::HttpHeaderName => "KNOWN_REGEX_HTTP_HEADER_NAME",
            Self::HttpHeaderValue => "KNOWN_REGEX_HTTP_HEADER_VALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KNOWN_REGEX_UNSPECIFIED" => Some(Self::Unspecified),
            "KNOWN_REGEX_HTTP_HEADER_NAME" => Some(Self::HttpHeaderName),
            "KNOWN_REGEX_HTTP_HEADER_VALUE" => Some(Self::HttpHeaderValue),
            _ => None,
        }
    }
}
