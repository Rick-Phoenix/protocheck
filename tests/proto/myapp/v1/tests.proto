syntax = "proto3";

package myapp.v1;

import "buf/validate/validate.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";

message ContainingTests {
  string name = 1 [(buf.validate.field).string = {
    in: [
      "alfredo",
      "maurizio"
    ]
    not_in: ["ermenegildo"]
  }];

  float float_field = 2 [(buf.validate.field).float = {
    in: [
      1.5,
      2.5
    ]
    not_in: [2.0]
  }];
  double double_field = 3 [(buf.validate.field).double = {
    in: [
      1.5,
      2.5
    ]
    not_in: [2.0]
  }];
  google.protobuf.Duration duration_field = 4 [(buf.validate.field).duration = {
    in: [
      {
        seconds: 3600
        nanos: 0
      }
    ]
    not_in: [
      {
        seconds: 0
        nanos: 0
      }
    ]
  }];
  int64 int64_field = 5 [(buf.validate.field).int64 = {
    in: [
      1,
      2
    ]
    not_in: [5]
  }];
}

message StringTests {
  string email = 1 [(buf.validate.field).string.email = true];
  string regex_test = 2 [(buf.validate.field).string.pattern = "^abc$"];
  string contains_test = 3 [(buf.validate.field).string.contains = "abc"];
  string not_contains_test = 4 [(buf.validate.field).string.not_contains = "abc"];
  string prefix_test = 5 [(buf.validate.field).string.prefix = "abc"];
  string suffix_test = 6 [(buf.validate.field).string.suffix = "abc"];
}

message RepeatedTest {
  message Person {
    option (buf.validate.message).cel = {
      id: "message.person_name"
      message: "name must be 'alfonso'"
      expression: "this.name == 'alfonso'"
    };

    string name = 1 [(buf.validate.field).cel = {
      id: "message_field.person_name"
      message: "name must be 'alfonso'"
      expression: "this == 'alfonso'"
    }];
  }

  repeated float unique_floats = 2 [(buf.validate.field).repeated.unique = true];
  repeated double unique_doubles = 3 [(buf.validate.field).repeated.unique = true];
  repeated string unique_strings = 4 [(buf.validate.field).repeated.unique = true];

  repeated Person people = 1 [(buf.validate.field).repeated.items.cel = {
    id: "repeated_item.person_name"
    message: "name must be 'alfonso'"
    expression: "this.name == 'alfonso'"
  }];
}

message Recursive {
  oneof oneofs {
    Recursive recursive_oneof = 3 [(buf.validate.field).cel = {
      id: "id.is_4"
      message: "id must be 4"
      expression: "this.id == 4"
    }];

    int64 tag = 4;
  }

  option (buf.validate.message).cel = {
    id: "id.is_2"
    message: "id must be 2"
    expression: "this.id == 2"
  };

  Recursive recursive = 1 [(buf.validate.field).cel = {
    id: "id.is_3"
    message: "id must be 3"
    expression: "this.id == 3"
  }];

  int64 id = 2;
}

message MessageMap {
  message Person {
    option (buf.validate.message).cel = {
      id: "message.person_name"
      message: "name must be 'alfonso'"
      expression: "this.name == 'alfonso'"
    };

    string name = 1 [(buf.validate.field).cel = {
      id: "message_field.person_name"
      message: "name must be 'alfonso'"
      expression: "this == 'alfonso'"
    }];
  }

  map<int64, Person> message_map = 1 [(buf.validate.field).map.values.cel = {
    id: "map_value.person_name"
    message: "name must be 'alfonso'"
    expression: "this.name == 'alfonso'"
  }];
}

message DurationMap {
  map<string, google.protobuf.Duration> duration_map = 1 [(buf.validate.field).map = {
    values: {
      duration: {
        gt: {
          seconds: 3600
          nanos: 0
        }
      }
      cel: {
        id: "duration_map_value"
        message: "duration map value must be more than 1h"
        expression: "this > duration('1h')"
      }
    }
  }];
}

message TimestampMap {
  map<string, google.protobuf.Timestamp> timestamp_map = 1 [(buf.validate.field).map = {
    values: {
      timestamp: {gt_now: true}
      cel: {
        id: "timestamp_map_value"
        message: "timestamp map value must be later than 2023"
        expression: "this > timestamp('2023-10-27T10:00:00Z')"
      }
    }
  }];
}

message BasicMap {
  map<string, string> string_map = 1 [(buf.validate.field).map = {
    min_pairs: 2
    max_pairs: 2
    keys: {
      string: {min_len: 3}
      cel: {
        id: "map_key_cel"
        message: "map key has to be 'abc'"
        expression: "this == 'abc'"
      }
    }
    values: {
      string: {max_len: 3}
      cel: {
        id: "map_value_cel"
        message: "map value has to be 'abc'"
        expression: "this == 'abc'"
      }
    }
  }];
}
